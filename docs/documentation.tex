\documentclass{article}

% ############### %
% PACKAGE IMPORTS %
% ############### %
\usepackage[utf8]{inputenc}

\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage[margin=80pt]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{longtable}
\usepackage{mathtools}
\usepackage[most]{tcolorbox}
\usepackage{tikz}
\usetikzlibrary{shadows}

\pagestyle{fancy}

% ################ %
% ENVIRONMENT DEFS %
% ################ %
\newenvironment{guide}[1]
{
	\begin{center}
		\begin{tcolorbox}[%
			colback=black!20, 
			boxrule=0pt, 
			title=Step-by-step: #1,
			enhanced,
			breakable,
			overlay unbroken={%
                \draw[line width=1pt, black, rounded corners]
        	    (frame.north west) rectangle (frame.south east);
			},
    		overlay first={%
        		 \draw[line width=1pt, black, rounded corners]
        	    (frame.south west) -- (frame.north west) -- (frame.north east) -- (frame.south east);
                \draw[line width=1pt, black]
                (frame.south west) -- (frame.south east);
            },
    		overlay middle={%
                \draw[line width=1pt, black]
        	    (frame.north west) rectangle (frame.south east);
        	},
    		overlay last={%
                \draw[line width=1pt, black, rounded corners]
        	    (frame.north west) -- (frame.south west) -- (frame.south east) -- (frame.north east);
                \draw[line width=1pt, black]
                (frame.north west) -- (frame.north east);
           	}
        ]{}
    	\begin{enumerate}
}
{
    		\end{enumerate}
    	\end{tcolorbox}
	\end{center}  	 
}

\newcommand{\guideimage}[1]
{
	\begin{center}
		\includegraphics[width=0.5\textwidth]{#1}
	\end{center}
}


% Adapted from this StackExchange post:
% https://tex.stackexchange.com/a/5227
\newcommand*\keystroke[1]
{
	\raisebox{-1.5pt}
	{
		\hspace{-8pt}
		\begin{tikzpicture}
		\node
		[
			draw,
			fill=black!65,
			drop shadow={shadow xshift=0.25ex,shadow yshift=-0.25ex,fill=black,opacity=0.75},
      		rectangle,
      		rounded corners=2pt,
      		inner sep=3pt,
      		outer sep=0pt,
      		line width=0.5pt,
      		font=\scriptsize\sffamily,
      		text=black!10
    	]
    	{
    		\hspace*{0.5pt}\tt #1\hspace*{0.5pt}
    	}
    	;
    	\end{tikzpicture}
		\hspace{-8pt}
  	}
}


% ############## %
% LISTINGS STUFF %
% ############## %
% FROM https://tex.stackexchange.com/a/656423
% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}



\lstdefinestyle{pythonstyling}{
language=Python,
basicstyle=\ttm\small,
morekeywords={self},              % Add keywords here
keywordstyle=\ttb\small\color{deepblue},
emph={__init__},          % Custom highlighting
emphstyle=\ttb\small\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false,
numbers=left,
stepnumber=1,
tabsize=1,
breaklines=true,
breakatwhitespace=false,
}

% ############## %
% VARIABLE SETUP %
% ############## %
\title{Blender Tools for GFS Documentation}
\author{Pherakki}
\date{v0.1}


% ############## %
% DOCUMENT START %
% ############## %
\begin{document}
\maketitle
\pagenumbering{gobble}
\clearpage

\tableofcontents
\clearpage

\pagenumbering{arabic} 

\section{Getting Started}
BlenderToolsForGFS is a \textbf{Blender 2.81+} plugin. It should work on all versions of Blender including and beyond 2.81 that are compatible with the 2.81 API. The plugin has been developed on versions 2.83 and 3.4.1. You should install and remove it like any other Blender plugin.

\subsection{A Note on Expectations}
This plugin should be viewed as a \textbf{supplement} to existing model-editing tools, and not as a replacement. You should, in particular, post-process any models exported from Blender in \textbf{GFD Studio}, following existing tutorials and knowledge to achieve your goals.

Please also note that although this document does offer a number of guides on bits of basic Blender usage required to use the plugin, this is not a guide on how to use Blender. If you are intending to work with models and animations, it is ultimately your responsibility to learn how to use Blender using the wealth of resources available on the internet.

This is also not a guide on how to mod games. Again, it is your responsibility to seek out or discover the information you require to attain any such goals.

What this guide \textit{is} intended for is to assist you in successfully exporting data from Blender to the GFS file format. Suggestions for improvements on how to do that are very much welcomed, as long as they do not fall out-of-scope for the essential use of the plugin.
\clearpage

\section{Import}
\subsection{Import Restrictions}
Currently, a subset of features of the GFS format are not supported by the plugin and cannot be exported. These are:
\begin{itemize}
\item File versions outside of the range 0x01104920 - 0x01105100
\end{itemize}
\noindent
There are also some additional considerations to bear in mind.
\begin{itemize}
\item During import, meshes are re-parented from their positioning node to the root node, whilst preserving their world transform. This is because there does not seem to be a straightforward way to make a mesh follow the transform of a bone whilst also being deformed by an armature without Blender double-counting transformations. These positioning nodes are also removed from the import if they are not used for any other purpose.
\item Animations of the Root Node and of mesh positioning nodes are not editable from Blender. Any mesh positioning node animations \textbf{will be messed up} by the Blender import if these nodes were not originally children of the root node. This must be fixed outside of Blender by re-parenting and repositioning these nodes.
\item Only non-BC7 DDS texture slots are currently importable in models.
\item There is a lot of extra data, such as EPL effects and physics, that is not explicity expressed as Blender data but is still attached to the model for export. This data is non-interactable from Blender in the current version. If some chunk of data is not mentioned in the documentation, you can assume that it is probably stored in this fashion.
\end{itemize}

\clearpage 

\subsection{Importing Model (GMD/GFS) Files}
\begin{guide}{Accessing the Model Import Menu}
\item Open the File menu and navigate to the \textbf{Import} \textgreater\space \textbf{GFS} \textgreater\space \textbf{GFS Model} submenu item.
\guideimage{images/import/import_gmd.png}
\item From the import options on the right, choose whether to set the Blender render speed to that which is appropraite for GFS models and whether to merge model vertices such that the mesh is smooth (recommended).
\guideimage{images/import/import_gmd_properties.png}
\item Select the GMD or GFS file to import using the file browser.
\end{guide}

\clearpage

\subsection{Importing Animation (GAP) Files}
\begin{guide}{Accessing the Animation Import Menu}
\item Ensure that you have first imported the model that the animation is modelled for.
\item Open the File menu and navigate to the \textbf{Import} \textgreater\space \textbf{GFS} \textgreater\space \textbf{GAP Animation} submenu item.
\guideimage{images/import/import_gap.png}
\item Select the armature for your imported model using the drop-down. Also choose whether to set the Blender render speed to that which is appropriate for GFS models.
\guideimage{images/import/import_gap_properties.png}
\item Select the GAP file to import using the file browser.
\end{guide}

\clearpage

\subsection{Blender Settings}
\subsubsection{Previewing Materials}
Many beginners to Blender are confused by the fact that models do not display their materials when it is first opened. Blender by default renders models in a ``Solid" representation that is useful for modellers editing meshes. You can preview materials instead by changing this render setting.
\begin{guide}{Previewing Materials}
\item Locate the \textbf{Viewport Shading} widget and select \textbf{Material Preview} mode.
\guideimage{images/import/import_preview_materials.png}
\end{guide}

\subsubsection{Importing Large Models}
\label{SECTION::ImportingLargeModels}
Some models, such as Field Models, are typically in such large units that they exceed the default render distance of Blender. In this instance, you may find it useful to increase Blender's render distance.\\
\begin{guide}{Increasing Blender's Render Distance}
\item Press the \keystroke{N} key to open the \textbf{Sidebar}.
\guideimage{images/import/import_field_open_menu.png}
\item Click the \textbf{View} tab in the \textbf{Sidebar}.
\guideimage{images/import/import_field_open_view.png}
\item Change the value in the \textbf{End} box to a value large enough for you to comfortably navigate the model.
\guideimage{images/import/import_field_set_distance.png}
\item Press the \keystroke{N} key to close the \textbf{Sidebar}.
\end{guide}

\subsubsection{Hiding Unused Bones}
On import, three bone layers will be created in the armature:
\begin{itemize}
\item All Bones
\item Bones used in Vertex Groups
\item Bones not used in Vertex Groups
\end{itemize}
Selecting one of these layers will allow you to hide these subsets of bones. Note that these groups are created \textbf{by the plugin} on import, and if you add new bones to a model then it is up to you to add bones to whatever bone layers you want.

\begin{guide}{Selecting Bone Layers}
\item Switch to Object Mode.
\guideimage{images/import/import_to_object_mode.png}
\item Select the model armature.
\item Click the Armature icon in the Properties Panel. Select the Bone Layer that is active in the Viewport.
\guideimage{images/import/import_bone_layer_select.png}
\end{guide}

\clearpage

\section{Editing Models and Animations}
\subsection{GFS Models}
Models are imported as Armature objects with meshes, cameras, and lights parented below them. Most of the objects imported from GFS files can carry additional information beyond pure geometry and shading data, which is outlined in the proceeding sections.

GFS models are very large compared to typical Blender scales. If parts of the model disappear as you zoom out, you will need to change the render distance of Blender as described in section \ref{SECTION::ImportingLargeModels}.

The data in the files are assumed to be oriented Y-up and with X-axis-oriented bones. During import, these are converted to the Z-up orientation and Y-axis-oriented bones to match the Blender conventions. On export, the Blender data is converted back to Y-up orientation and X-axis-oriented bones. 

\subsubsection{Bones}
\label{SECTION::EditingBones} 
There are no special considerations for bones beyond how they behave in Blender. However, bones do also have some additional information that can be attached to them not representable in Blender. These can be accessed from the \textbf{GFS Node} panel in the \textbf{Bone Properties}.

\begin{itemize}
\item \textbf{Unknown Float}: Unknown. Always seems to take a value of 1.
\item \textbf{Properties}: Custom properties attached to the bone. See section \ref{SECTION::GfsProperties} for further details.
\end{itemize}

\begin{guide}{Accessing Extra Bone Properties}
\item Select the armature of the model either in the Viewport or in the Outliner.
\guideimage{images/editing_models/edits_select_armature.png}
\item Switch to Pose Mode.
\guideimage{images/editing_models/edits_to_pose_mode.png}
\item Select a bone and select the Bone icon in the Properties panel. You will find a panel called ``GFS Node" containing the additional Bone Properties.
\guideimage{images/editing_models/edits_bone_properties.png}
\end{guide}
\clearpage

\subsubsection{Rest Pose}
GFS models have a \textbf{rest pose} in addition to the bind pose. The bones are imported in the \textbf{bind pose}, and the \textbf{rest pose} is added as a single-frame animation. The \textbf{rest pose} is used as a ``default transform" for any animations, such that any bones without animation data uses the \textbf{rest pose} instead. If you want the \textbf{rest pose} to differ from the \textbf{bind pose}, create a single-frame action and push it to an NLA track called \textbf{Rest Pose}. This should always be at the \textbf{bottom} of the NLA editor, since it should have the lowest priority.

\subsubsection{Meshes}
Meshes that belong to a GFS model are parented under an armature. Meshes can use an armature deform with vertex groups as usual inside Blender. However, each vertex is only allowed to be part of a maximum of 4 vertex groups, and a maximum of 256 vertex groups are permitted across the entire model. If two meshes are weighted to the same bone, this counts as two vertex groups, since vertex groups are tied to the transform of a mesh in the GFS file format. The two vertex groups can be counted as one if meshes are parented to each other, as will be described momentarily.

The transform of the mesh inside Blender is exported as the mesh transform within the GFS files. Note however that meshes can be parented under other meshes to ensure that they share a transform. In this situation, the transform of the child-mesh is ignored and should always be a unit transform if you want to accurately see what will be exported in the viewport. In addition, if a mesh and its parent-mesh both use the same bone as a vertex group, it will be counted once instead of double-counted since both meshes have the same transform. Only one level of mesh-to-mesh parenting will be detected on export.

\begin{guide}{Mesh Parenting for GFS}
\item Meshes must be parented under an armature. The transform of a mesh dictates the transform of the mesh in the exported file.
\guideimage{images/editing_models/edits_parent_mesh.png}
\item Meshes can also be parented under other meshes. The transform of these child meshes will be ignored. Parenting a mesh under another mesh ensures that they will share a transform in the exported file and vertex groups used by both meshes will not be double-counted by the file format.
\guideimage{images/editing_models/edits_child_mesh.png}
\end{guide}

\begin{guide}{Unparenting Objects within Blender}
\item Select an object in the outliner or in the viewport.
\item Press \keystroke{Alt} + \keystroke{P} with the mouse in the Viewport.
\item Select either:
\begin{enumerate}
\item \textbf{Clear Parent} if you want to unparent the object from its parent \textbf{and} move the mesh so that its transform is relative to the origin.
\item \textbf{Clear and Keep Transform} if you want to unparent the object from its parent \textbf{and} edit the mesh's transform so that it stays in the same place in the viewport.
\end{enumerate}
Ignore \textbf{Clear Parent Inverse}.
\guideimage{images/editing_models/editing_unparent.png}
\end{guide}

\begin{guide}{Parenting Objects within Blender}
\item Select the child object in the outliner or in the viewport.
\guideimage{images/editing_models/edits_parent_1.png}
\item Select the parent object in the outliner or in the viewport with \keystroke{Ctrl} + Click.
\guideimage{images/editing_models/edits_parent_2.png}
\item Press \keystroke{Ctrl} + \keystroke{P} with the mouse in the Viewport.
\item Select either:
\begin{enumerate}
\item \textbf{Object (Without Inverse)} if you want to parent the object and reset its transform.
\item \textbf{Object (Keep Transform Without Inverse)} if you want to parent the object \textbf{and} edit the mesh's transform so that it stays in the same place in the viewport.
\end{enumerate}
\guideimage{images/editing_models/edits_parent_3.png}
\item In any situation, if after parenting your child object's transform is not what you expected, then:
\begin{itemize}
\item Select the child object.
\item Press \keystroke{Alt} + \keystroke{P} with the mouse in the Viewport.
\item Click \textbf{Clear Parent Inverse}.
\end{itemize}
This will remove the hidden ``parent inverse" matrix that sometimes gets inserted when parenting objects. This is harmless, but merely means that you object's transform may not align with what you see in the viewport if it is not a unit transform.\\
\guideimage{images/editing_models/editing_unparent.png}
\end{guide}

Meshes have certain attributes that may be exported. These are:
\begin{itemize}
\item \textbf{Export Bounding Box}/\textbf{Sphere}: Define a bounding Box / Sphere on export.
\item \textbf{Unknown Flag}: The purpose of Unknown Flags is not known. Checking and unchecking these may cause or fix crashes.
\item \textbf{Unknown 0x12}: Purpose unknown.
\item The GFS Node sub-panel will appear if the Mesh is not parented under another Mesh. Refer to section \ref{SECTION::EditingBones} for further details.
\end{itemize}

\begin{guide}{Accessing Extra Mesh Attributes}
\item Select the mesh in the Outliner or in the Viewport.
\guideimage{images/editing_models/edits_select_mesh.png}
\item Switch to Object Mode.
\guideimage{images/editing_models/edits_to_object_mode.png}
\item Select the Mesh icon in the Properties panel. You will find a panel called ``GFS Mesh" containing the additional Mesh attributes.
\guideimage{images/editing_models/edits_mesh_properties.png}
\end{guide}

\underline{\textbf{WARNINGS}}
\begin{itemize}
\item Many tutorials and help articles will tell you to \textbf{Apply Transforms} to your mesh to reset their transforms to a unit transform. \textbf{This is dangerous}. When you \textbf{Apply Transforms}, you are translating, rotating, and scaling the vertices that make up the mesh, rather than applying an extra transform on top of the mesh. This means that, for example, your mesh will now use the origin as the reference point from which it rotates and scales, rather than the point around which the mesh was modelled.
\end{itemize}

\subsubsection{Materials}
\label{SECTION::EditingMaterials}

Materials are not yet sufficiently understood to a degree whereby they can be consistently rendered in Blender. Therefore, materials are only represented in Blender as the Diffuse Texture of the material and all other properties are inferred from attributes or the names of Shader Nodes. Edits to the GFS Material attributes will, more often than not, simply lead to the model crashing any game that loads it. Due to this, editing materials from Blender is \textbf{not} currently recommended, except for the purposes of:
\begin{enumerate}
\item Adding textures to a material.
\item Perhaps minor tweaks to attributes.
\item Researching what the attributes do.
\end{enumerate}
You will have much more success following the strategy of current model editing guides: post-processing the model in \textbf{GFD Studio} by copying materials from other models onto your exported model. How to do this is beyond the scope of this documentation but detailed tutorials are available online.

In the future, when materials are properly understood, a custom Shader Node Group should be implemented that allows the material to be rendered in a meaningful fashion, and allowing the values of attributes to be auto-calculated such that they do not crash the game. \textbf{There is not enough knowledge currently to do this and any contributions to material research enabling this feature is highly welcomed.}

There are then two essential pieces to Material editing:
\begin{itemize}
\item Texture Samplers
\item GFS Material Attributes
\end{itemize}

\paragraph{Texture Samplers:}You can edit the textures used by a material by accessing the Shader Nodes. The first step is to open the Shader Node Editor.
\begin{guide}{Opening the Shader Node Editor}
\item Select the mesh in the Outliner or in the Viewport.
\guideimage{images/editing_models/edits_select_mesh.png}
\item Switch to Object Mode.
\guideimage{images/editing_models/edits_to_object_mode.png}
\item Select the Material icon in the Properties panel.
\guideimage{images/editing_models/edits_select_material.png}
\item Select the Shader Editor.
\guideimage{images/editing_models/edits_open_shader_nodes.png}
\end{guide}

You can then set create new samplers to be exported and set their GFS attributes. There are nine types of textures available in the GFS format. Each material can have \textbf{one} of each type, and the plugin will recognise which type of sampler a node represents by the \textbf{name} of the node. The recognised names are:
\begin{itemize}
\item Diffuse Texture
\item Normal Texture
\item Specular Texture
\item Reflection Texture
\item Highlight Texture
\item Glow Texture
\item Detail Texture
\item Night Texture
\item Shadow Texture
\end{itemize}

Note also that the UV maps must also have specific names due to the way they are stored in the GFS file format. The permitted names are:
\begin{itemize}
\item UV0
\item UV1
\item UV2
\item UV3
\item UV4
\item UV5
\item UV6
\item UV7
\end{itemize}
meaning that up to 8 maps are allowed per mesh.

\begin{guide}{Editing Texture Samplers}
\item Inside the Shader Editor, select or create an Image Node.
\item Select the \textbf{Node} tab in the Sidebar. If the Sidebar is not open, press \keystroke{N} with the mouse inside the Shader Editor.
\item Set the name of the node to one of the nine accepted names by changing the value in the Name field.
\guideimage{images/editing_models/edits_rename_shader_node.png}
\item Select or create a UV Map node. Select a UV map present on the mesh from the drop-down on the node and hook the UV connector up to the Vector connector on the Texture node.
\guideimage{images/editing_models/edits_set_node_uv_map.png}
\item You can access the properties of a texture sampler by selecting the \textbf{GFS Texture} tab in the Sidebar. The properties for the sampler are given in the \textbf{GFS Texture Sampler} panel.
\guideimage{images/editing_models/edits_texture_sampler_properties.png}
\end{guide}

\paragraph{GFS Material Attributes:}
\noindent Materials have certain attributes that may be exported. These are:
\begin{itemize}
\item \textbf{Unknown Flags}: The purpose of Unknown Flags is not known. Checking and unchecking these may cause or fix crashes.
\item \textbf{Enable Vertex Colors}: Use Color Map data on the mesh.
\item \textbf{Enable UV Anims}: Allow the UV coordinates of the mesh to be animated.
\item \textbf{Use Light 2}: Purpose unknown.
\item \textbf{Purple Wireframe}: Render the mesh as a purple wireframe.
\item \textbf{Requires Normals}: Whether the material requires vertex normals to work. If this is active, any meshes using this material will be exported with vertex normals.
\item \textbf{Requires Tangents}: Whether the material requires vertex tangents to work. If this is active, any meshes using this material will be exported with vertex tangents.
\item \textbf{Requires Binormals}: Whether the material requires vertex binormals to work. If this is active, any meshes using this material will be exported with vertex binormals.
\item \textbf{Requires Color0}: Whether the material requires vertex colours in slot 0 to work. If this is active, any meshes using this material will be exported with vertex colours taken from a Color map called ``Map0" if it exists; if it does not, the mesh will be exported with an opaque white colour (1.0, 1.0, 1.0, 1.0) at each vertex.
\item \textbf{Requires Color1}: Whether the material requires vertex colours in slot 1 to work. If this is active, any meshes using this material will be exported with vertex colours taken from a Color map called ``Map1" if it exists; if it does not, the mesh will be exported with an opaque white colour (1.0, 1.0, 1.0, 1.0) at each vertex.
\item The GFS Node sub-panel will appear if the Mesh is not parented under another Mesh. Refer to section \ref{SECTION::EditingBones} for further details.
\end{itemize}
\begin{guide}{Accessing Extra Material Attributes}
\item Select the mesh in the Outliner or in the Viewport.
\guideimage{images/editing_models/edits_select_mesh.png}
\item Switch to Object Mode.
\guideimage{images/editing_models/edits_to_object_mode.png}
\item Select the Material icon in the Properties panel. You will find a panel called ``GFS Material" containing the additional Material attributes.
\guideimage{images/editing_models/edits_material_properties.png}
\end{guide}

\subsubsection{Textures}
Textures must be DDS images with either no compression, or DXT1, DX3, or DXT5 compression. BC7 textures cannot currently be loaded by Blender and are currently unsupported. In the future, BC7 textures should be loadable \textit{via} an automatic conversion to a Blender-readable format.

\noindent Materials have certain attributes that may be exported. These are:
\begin{itemize}
\item \textbf{Unknown 1}: Purpose unknown.
\item \textbf{Unknown 2}: Purpose unknown.
\item \textbf{Unknown 3}: Purpose unknown.
\item \textbf{Unknown 4}: Purpose unknown.
\end{itemize}
These attributes can be edited from the \textbf{GFS Texture} Sidebar panel on a Texture Image node in the Shader Editor, as described in section \ref{SECTION::EditingMaterials}.

\subsubsection{Cameras}
Cameras are constrained to a bone in the model armature with a \textbf{Child Of} constraint. Due to the way that bones are imported, \textbf{you will need a 90 degree rotation in the Z axis} on the camera to make it point ``horizontally". The camera will be exported in whatever orientation it is in within Blender, however \textbf{it is strongly recommended} to just keep a 90-degree Z-rotation on the camera and do all other positioning using the bone it is constrained to.

For a camera to be recognised for export, you must do one of the following:
\begin{itemize}
\item Constrain the camera to follow a bone with a ``Child Of" constraint.
\item Parent the Camera to a bone. Note that parenting a Camera to a bone will place the camera at the tail of the bone rather than the head, although this should not affect the pose in which the camera is exported.
\end{itemize}

Some properties of Blender cameras will be exported to GFS camera properties, and some properties are not represented in Blender. This is described below.
\begin{guide}{Accessing Camera Properties}
\item In the \textbf{Camera Data} Properties panel, there are a number of camera properties. In the \textbf{Lens} section, the \textbf{Type} must be set to \textbf{Perspective} and the \textbf{Lens Unit} to \textbf{Field of View}. The \textbf{Field of View} attribute will be exported, although it may not exactly match up with the in-game field-of-view in the current version of the plugin. Additionally, the \textbf{Clip Start} and \textbf{Clip End} fields will be exported and will appear in-game as they do in Blender.
\item Furthermore, there are two properties not represented in Blender that can be exported, found in the \textbf{GFS Camera}. \textbf{Aspect Ratio}s can be represented in Blender, but only for the entire scene and not for individual cameras, so this is not currently represented. \textbf{Unknown 0x50} is unknown.
\guideimage{images/editing_models/edits_camera_properties.png}
\end{guide}

\subsubsection{Lights}
Lights are constrained to a bone in the model armature with a \textbf{Child Of} constraint. Due to the way that bones are imported, \textbf{you will need a 90 degree rotation in the Z axis} on the camera to make it point ``horizontally". The light will be \textbf{exported assuming a 90-degree Z-rotation on the light}---do all other positioning using the bone it is constrained to.

For a light to be recognised for export, you must do one of the following:
\begin{itemize}
\item Constrain the Light to follow a bone with a ``Child Of" constraint.
\item Parent the Light to a bone. Note that parenting a Light to a bone will place the light at the tail of the bone rather than the head, \textbf{and the light will be repositioned to the head of the bone during export due to GFS file format constraints}.
\end{itemize}

Some properties of Blender lights will be exported to GFS light properties, and some properties are not represented in Blender. This is described below.
\begin{guide}{Accessing Light Properties}
\item In the \textbf{Light Data} Properties panel, there are a number of light properties.
The only Blender property currently exported is the \textbf{Color} property, which sets the RGB light color.
\item The additional properties are in the \textbf{GFS Light} panel. There are first three elements common to all lights:
\begin{itemize}
\item \textbf{Color Alpha} is the alpha channel of the light color.
\item \textbf{Color 1} is a color variable that does not seem to be used.
\item \textbf{Color 3} is a color variable that does not seem to be used.
\end{itemize}
There are then three kinds of light, selectable from the drop-down:
\begin{itemize}
\item \textbf{Type 1}: Unknown light type, does not appear to render in-game. Has no specific properties.
\item \textbf{Sphere}: A point light that can have an attentuation radius. This has the unknown properties \textbf{unknown 0x34}, \textbf{unknown 0x38}, and \textbf{unknown 0x3C}, plus an \textbf{unknown setting}. If the unknown setting is active, the point light will illuminate everything within the \textbf{inner radius}, and attenuate to zero illumination between the \textbf{inner radius} and \textbf{outer radius}. Switching the setting off instead provides the settings \textbf{unknown 0x48}, \textbf{unknown 0x4C}, and \textbf{unknown 0x50}. Attempts to get a light to render using these variables have been unsuccessful.
\item \textbf{Hemisphere}: A spot light that can have an attentuation radius. This has the unknown properties \textbf{unknown 0x54}, \textbf{unknown 0x58}, \textbf{unknown 0x5C}, \textbf{unknown 0x60}, \textbf{unknown 0x64}, \textbf{unknown 0x68}, \textbf{unknown 0x6C}, and \textbf{unknown 0x70}. This also has an \textbf{Unknown Setting} similar to the Sphere light. In principle these settings could be mapped to the Blender ``Spot Shape", but lights should be better understood overall before implementing this.
\end{itemize}
At the end of the properties is a list of flags. Only \textbf{flag 0} seems to be used amongst the provided flags, and its purpose is unknown.
\guideimage{images/editing_models/edits_light_properties.png}
\end{guide}


\subsubsection{Physics}
Model physics are not currently editable from Blender, but should be preserved for re-export.

\clearpage
\subsection{GFS Animations}
In this section, the three major kinds of animation are covered. Sections~\ref{SECTION::Edits::Animations::NormalAnimations}, \ref{SECTION::Edits::Animations::BlendAnimations}, and \ref{SECTION::Edits::Animations::LookAtAnimations} cover the properties and Blender data required for each of these types to be exported and displayed correctly. Section~\ref{SECTION::Edits::Animations::AnimationPacks} covers how to organise the set of animations in an Animation Pack that can be exported. In section~\ref{SECTION::Edits::Animations::TipsForEditing}, some useful information on editing Blend animations from within Blender is provided.

Currently, only \textbf{bone animations} are editable from within Blender. There are (at least) four other kinds of animation, but they are not exposed to the user for the following reasons:
\begin{itemize}
\item \textbf{Material Animations}: Not enough known about materials to create an animation node with animatable inputs.
\item \textbf{Camera Animations}: No strategy currently developed to link Camera object animations to the corresponding Armature animation.
\item \textbf{Morph Animations}: No strategy currently developed to link Shape Key animations to the corresponding Armature animation.
\item \textbf{Animation Type 5}: Unknown animation type, so nothing can be done with it currently. 
\end{itemize}

GFS Animations are expected to be rendered at \textbf{30 FPS}. Blender by default renders at \textbf{24 FPS}. Animations will be imported assuming a 30 FPS render speed so that animation frames can be placed at integer frame indices. You should change Blender's animation speed to 30 FPS to preview the animations at the correct speed, either by changing it in the scene properties or by checking the box to set Blender to 30 FPS in the import window.

If an animation additionally has a custom ``speed", this speed is baked into the animation frames. This will cause the animation frames to be placed at non-integer frame values.

\subsubsection{Normal Animations}
\label{SECTION::Edits::Animations::NormalAnimations}
``Normal Animations" are regular animations. The animated quantities in these animations should override those that are present in the Rest Pose. In-game, all interpolations are done with \textbf{linear interpolation (LERP)}, except for quaternion animations which are done with \textbf{spherical linear interpolation (SLERP)}. For this reason, to ensure that the animation you see in Blender is accurately reflected in-game, you should ensure the following settings are applied:
\begin{itemize}
\item The Strip Blending should be set to \textbf{REPLACE}.
\item The keyframe interpolation should be set to \textbf{LINEAR} for all animations except for \textbf{rotation\_quaterion}, which should be set to \textbf{BEZIER}.
\end{itemize}
See Section~\ref{SECTION::Editing::Animations::TipsForEditing::AutoCorrect}, Subitem ``Auto-Correcting Actions" for information on how to apply these settings automatically.

\textbf{Normal Animations} have a set of properties that also need to be exported. Details on these are given below.

\begin{guide}{Accessing Normal Animation Properties}
\item The animation properties can be found by selecting a strip in the NLA editor and navigating to the ``GFS Animation" panel in the ``Strip" sidebar panel. You can use the \keystroke{N} key to open and close the sidebar whilst the mouse cursor is inside the NLA editor.
\item The \textbf{Category} should be set to ``Normal". Most of the \textbf{Unknown Flags} are unused. The first five flags are usually ticked if the following animations are present:
\begin{enumerate}
\item Flag 0 - Bone animations
\item Flag 1 - Material animations
\item Flag 2 - Camera animations
\item Flag 3 - Morph animations
\item Flag 4 - Unknown animations
\end{enumerate}
but since these do not seem to influence how animations are displayed and do not have an exact correspondence to these types of animation being present, they are left as unnamed flags for now.
\guideimage{images/editing_models/edits_normal_animations_1.png}
\item Further down, you can set ``Look At" animations for a Normal Animation. A \textbf{LookAt animation} is a kind of \textbf{Blend Animation} that makes a character look up, down, left, and right. Further details can be found in sections~\ref{SECTION::Edits::Animations::BlendAnimations} and \ref{SECTION::Edits::Animations::LookAtAnimations}. If you tick the box saying that an animation has lookat animations, you \textbf{must select all four animations you want to use as lookats} in order to successfully export. You can do this by clicking the animation boxes and selecting the animation that pops up. The only available animations are those that have been given the \textbf{LookAt} category.
The role of the LookAt factors is unknown.
In addition, animations can have GFS Properties like bones can. See section~\ref{SECTION::GfsProperties} for more information.
\guideimage{images/editing_models/edits_normal_animations_2.png}
\end{guide}

\subsubsection{Blend Animations}
\label{SECTION::Edits::Animations::BlendAnimations}
\textbf{Blend Animations} are animations that are overlaid on \textbf{Normal Animations}. The animations are combined by combining each transformation channel individually. Positions and scales are added, and quaternions are combined with quaternion multiplication. Therefore, the Strip Blending type should be set to \textbf{COMBINE}. Keyframe interpolation should be handlded the same as the \textbf{Normal Animations}. However, Blender will attempt to \textbf{multiply} scale channels instead of adding them under the \textbf{COMBINE} Strip Blending mode. For this reason, scales should be separated to their own action with the \textbf{ADD} Strip Blending mode, and given the special \textbf{Blend Scale} category rather than the \textbf{Blend} category. Details on this are given in the Blend Properties Step-By-Step below, which also discusses other Blend animation properties. This means that any scales present in a \textbf{Blend Animation} will be ignored on export, and instead taken from a linked \textbf{Blend Scale Animation} if one is present.
\begin{guide}{Accessing Blend Animation Properties}
\item The \textbf{category} for Blend animations is \textbf{Blend}. The \textbf{Unknown Flags} are the same as the \textbf{Normal Animations}.
\guideimage{images/editing_models/edits_blend_animations_1.png}
\item Instead of \textbf{LookAt} animations, \textbf{Blend} animations can link to a \textbf{Blend Scale} animation as described above. To link a \textbf{Blend Scale} animation, select one from the dropdown.
\guideimage{images/editing_models/edits_blend_animations_2.png}
\end{guide}

\subsubsection{LookAt Animations}
\label{SECTION::Edits::Animations::LookAtAnimations}
A \textbf{LookAt} animation is a special \textbf{Blend} animation used to represent looking left, right, up, and down. This is typically just a single frame representing the pose. \textbf{Normal Animations} can link to a \textbf{LookAt} animation from their properties panel. If the \textbf{LookAt} animation is not linked to a \textbf{Normal Animation}, it will not be exported.
\begin{guide}{Accessing LookAt Animation Properties}
\item The \textbf{category} for a \textbf{LookAt} animation is \textbf{LookAt}. All properties are the same as \textbf{Blend Animations}.
\guideimage{images/editing_models/edits_lookat_animations.png}
\end{guide}

\subsubsection{Animation Packs}
\label{SECTION::Edits::Animations::AnimationPacks}
Animations are exported as an \textbf{Animation Pack}. This animation pack is either exported \textbf{inside a GMD/GFS file}, or exported as \textbf{a separate GAP animation file}. When exporting a GMD/GFS file, you will be given the option to pack animations inside it or not. See section~\ref{SECTION::EXPORT::ExportingModels} for further information.

Currently, \textbf{only the most recently loaded animation pack properties are available inside the plugin}. That means that if you load a model that contains an animation pack, and then load a GAP file on top of it, the properties of the internal animation pack \textbf{will be overwritten}. Since models containing animations typically do not require external animation files, this should not be a problem. When editing external animation packs, ensure that the pack you intend to edit is loaded last. All available animations in the NLA track will be exported, so either delete unwanted animations from the NLA editor before export, or only load the animation pack you wish to edit. If you pack too many animations inside an animation pack, you can fix this with an external program such as \textbf{GFD Studio} or the Python interface.

If a sensible way to easily separate invididual animation packs without making it complicated to assign animations to them can be found, this feature will be reworked to allow multiple animation packs to co-exist within Blender and export individually.

Animation Pack properties are stored on a model armature. The section below will cover the specifics of this.
\begin{guide}{Accessing Animation Pack Properties}
\item Animation Pack properties can be found in the \textbf{Armature Data} panel of the Properties Panel.
\item The \textbf{Unknown Flags} are unknown and appear to be completely unused except for Flag 3. The purpose of Flag 3 is unknown. An animation pack can also have some global \textbf{LookAt} animations, similar to a \textbf{Normal Animation}. See section~\ref{SECTION::Edits::Animations::NormalAnimations} for further information.
\item Bear in mind that \textbf{only the properties of the most recently imported animation pack for a particular model} are saved.
\guideimage{images/editing_models/edits_animation_pack.png}
\end{guide}

\subsubsection{Tips for Editing Animations in Blender}
\label{SECTION::Edits::Animations::TipsForEditing}

\paragraph{Auto-Correcting Actions}
\label{SECTION::Editing::Animations::TipsForEditing::AutoCorrect}
\begin{guide}{Auto-Correcting Actions}
\item The interpolation and strip blending of an NLA strip and action can be automatically set when switching the action type. Do this inside the Animation Properties.
\item The animation properties can be found by selecting a strip in the NLA editor and navigating to the ``GFS Animation" panel in the ``Strip" sidebar panel. You can use the \keystroke{N} key to open and close the sidebar whilst the mouse cursor is inside the NLA editor.
\item Check the \textbf{Auto-Correct Action} box.
\guideimage{images/editing_models/edits_autocorrect_animations.png}
\item Changing the animation \textbf{category} will now automatically change the interpolation and strip blending types for those appropriate for the selected category. This will not be done when first checking the box, so switch to a different category and back to apply the changes.
\end{guide}

\paragraph{Previewing with the NLA Editor}
\label{SECTION::Editing::Animations::TipsForEditing::PreviewingNLA}
\begin{guide}{Previewing with the NLA Editor}
\item Unmute whichever animations you want to preview. You should unmute a \textbf{single} \textbf{Normal Animation} plus whatever \textbf{Blend Animation}s you want to see overlaid on it.
\item The \textbf{Rest Pose} should \textbf{always} be unmuted.
\item Actions at the \textbf{top} of the editor have the highest priority. Should should have the \textbf{Rest Pose} at the bottom, followed by the \textbf{Normal Animations}, and then any \textbf{Blend Animations}.
\guideimage{images/editing_models/edits_previewing_blends_1.png}
\end{guide}

\paragraph{Previewing Blend Animations during Editing}
\label{SECTION::Editing::Animations::TipsForEditing::PreviewingBlends}
\begin{guide}{Previewing Blend Animations during Editing}
\item Unmute whichever \textbf{Normal Animation} you want to use as a base, and the \textbf{Blend Animation} you want to edit in the NLA editor.
\guideimage{images/editing_models/edits_previewing_blends_1.png}
\item Press \keystroke{Tab} to pin the action to the Action Editor.
\guideimage{images/editing_models/edits_previewing_blends_2.png}
\item You can now edit the action in the Action Editor whilst previewing the full effect of the other umutued NLA tracks.
\end{guide}

\clearpage

\subsection{GFS Properties}
\label{SECTION::GfsProperties}
Bones, armatures, meshes, and animations can have additional \textbf{GFS properties}. These can be added with the \textbf{GFS Properties} collection widget in their corresponding UI panels. When adding a property, you will be required to provide a name, data type, and then the data the property will store. Although the name fields are free text fields, there do appear to be specific properties that are looked for and will do certain things. For this reason the properties box may be replaced with sub-panels implementing this behvaviour automatically once it is fully understood. For now, like with everything else that isn't fully understood about the format, any edits you make will have to be somewhat manual.

\begin{guide}{Manipulating GFS Properties}
\item Navigate the the properties panel for the selected object.
\item Within the object's properties panel, locate the \textbf{GFS Node} subpanel. Within that panel, locate the \textbf{Properties} subpanel.
\item Properties attached to the object will be displayed in the box. The selected property is highlighted in a different colour. You can add, remove, and re-order properties with the four buttons on the right of the box.
\item Change the name of a property by editing the value in the leftmost box.
\item Change the property data type by selecting a value from the dropdown.
\item Change the attached data by editing the rightmost box(es).
\guideimage{images/editing_models/edits_gfs_properties.png}
\end{guide}

\clearpage

\subsection{EPLs}
\label{SECTION::Edits::Epls}
EPL files are not currently editable in Blender. GFS files containing EPLs are loadable, but the EPL data will not be accessible. GFS files contained within EPLs can be extracted by other programs or by using this plugin as a library for the Python programming language, as described in section~\ref{SECTION::PythonLibrary}. These extracted GFS files may then be possible to open in Blender, edit, and then re-inject into the EPL files with other programs or \textit{via} the Python interface. Note however that, as of this version of the plugin, this is not well-tested nor intended to be an end-user feature. Users are welcome to use the library in this way, but are reminded that since it is an unsupported part of the library, pull requests that improve the feature are significantly more likely to get attention than issue tickets asking for improvements to it.

If sections of EPLs can be sensibly imported and exported from Blender, such as submodels, EPLs may be better supported in future versions of the plugin.

\clearpage

\section{Export}
\subsection{Exporting Model (GMD/GFS) Files}
\label{SECTION::EXPORT::ExportingModels}
\begin{guide}{Accessing the Model Export Menu}
\item Open the File menu and navigate to the \textbf{Export} \textgreater\space \textbf{GFS} \textgreater\space \textbf{GFS Model} submenu item.
\guideimage{images/export/export_gmd.png}
\item From the export options on the right, choose:
\begin{itemize}
\item Whether to export animations packed into the model.
\item Whether to strip any vertex groups from the export that do not correspond to a bone in the armature. Leaving this option unticked means that undefined vertex groups will cause an error when attempting to export.
\item Whether to recalculate tangents on export if a mesh needs to be exported with tangents. This can be useful if an imported model has incorrect tangent vectors, and if the Blender tangent calculator gives better results. This is active by default.
\item Which file version to export as.
\end{itemize}
\guideimage{images/export/export_gmd_properties.png}
\item Set a filename and export.
\end{guide}

\subsection{Exporting Animation (GAP) Files}
\label{SECTION::EXPORT::ExportingAnimations}
\begin{guide}{Accessing the Animation Export Menu}
\item Open the File menu and navigate to the \textbf{Export} \textgreater\space \textbf{GFS} \textgreater\space \textbf{GAP Animation} submenu item.
\guideimage{images/export/export_gap.png}
\item From the export options on the right, choose which file version to export as.
\guideimage{images/export/export_gap_properties.png}
\item Set a filename and export.
\end{guide}

\clearpage

\section{BlenderToolsForGFS as a Python Library}
\label{SECTION::PythonLibrary}
\textbf{NOTE: This section is for users of the Python programming language who wish to write scripts using the plugin. A user will not get much out of this section without some knowledge of Python. if you need to use the library's scripting API, you are encouraged to pick up the basics of Python using the wealth of information freely available on the internet.}\\\\
\noindent
\textbf{NOTE: The API is currently unstable. This document should be correct for whatever release of the tools it is labelled for, but the same cannot be said for development versions. The documentation should be fully updated once feature development for each new release is complete. You should expect the API to change between versions as the file format becomes better understood and smarter ways of arranging and creating data become clear.}
\\\\
\noindent
The Blender plugin can also be used as a plain Python library for manipulating GFS and EPL files. This is possible because all Blender-related code is not loaded by default when initialising the plugin, and because the file-editing code is well-separated from the Blender interface. Furthermore, the non-Blender part of the plugin only utilises the standard library, and therefore no additional third-party libraries are required in order to use the plugin as a library. Using the plugin in this manner is outlined in section \ref{SECTION::UsingAsAPythonLibrary}. \textbf{However, bear in mind that this is not fully documented since it is not yet intended as an end-user feature. Adventurous users can use the Python API, but should bear in mind that there are many ways to create annoying data inconsistencies. This can be remedied with further development to make the Python API safer to use by an end-user.}

If you have the `bpy' package installed, you can activate the plugin's Blender interface and write Blender scripts outside of Blender. You can also write these scripts inside Blender with the scripting feature. Notes on how to use the plugin in this manner are given in \ref{SECTION::UsingAsABlenderPlugin}.

\subsection{Python Library Usage}
\label{SECTION::UsingAsAPythonLibrary}
GMD, GFS, GAP, and EPL files can be manipulated with the Python API, which can be imported independently from the Blender Interface.

\subsubsection{GFS/GMD/GAP}
The first thing to do is to import the \textbf{GFSInterface} object.
\begin{lstlisting}[style=pythonstyling]
from BlenderToolsForGFS import GFSInterface
\end{lstlisting}
This object can be used to access various elements of the file. First of all, you will need to load a file.
\begin{lstlisting}[style=pythonstyling]
gi = GFSInterface.from_file(filepath=...) 
\end{lstlisting}
The GFSInterface can be written to a file with the \textbf{to\_file(filepath, version)} method.
\begin{lstlisting}[style=pythonstyling]
# version is an int, e.g. 0x01105100
gi.to_file(filepath=..., version=...)
\end{lstlisting}

The available attributes of the GFSInterface are given below.\\
These are likely to be changed to read-only properties with \textbf{add()} and \textbf{remove()} methods in the future.
\begin{center}
\begin{longtable}{p{.2\textwidth}p{.33\textwidth}p{.46\textwidth}}
\hline
Name & Type & Description\\
\hline
meshes & List[MeshInterface] & A list of meshes.\\
cameras & List[CameraInterface] & A list of cameras.\\
lights & List[LightInterface] & A list of lights.\\
epls & List[EPLInterface] & A list of epls.\\
bones & List[NodeInterface] & A list of nodes/bones.\\
materials & List[MaterialInterface] & A list of materials.\\
textures & List[TextureInterface] & A list of textures.\\
animations & List[AnimationInterface] & A list of normal animations.\\
blend\_animations & List[AnimationInterface] & A list of blend animations.\\
lookat\_animations & LookAtAnimationsInterface & A container for the global lookat animations.\\
\hline
\end{longtable}
\end{center}

New elements can be added to these attributes with the following methods.
\begin{center}
\begin{longtable}{p{.15\textwidth}p{.2\textwidth}p{.25\textwidth}p{.39\textwidth}}
\hline
Name & Return & Inputs & Input Description\\
\hline
add\_mesh & MeshInterface & node\_id & Node that the MeshInterface should be attached to.\\
& & vertices & A list of Vertex objects.\\
& & material\_name & The name of the material used by the mesh.\\
& & indices & Vertex indices that are used to create the triangles. This is a flat list, with every three indices creating a triangle.\\
& & morphs & A list of lists of 3D position vectors. Each sub-list represents a position offset for its corresponding vertex. Each sub-list should have the same number of entries as the mesh vertices.\\
& & unknown\_0x12 & Unknown integer. Usually 0.\\
& & unknown\_float\_1 & Unknown float. May be None is unknown\_float\_2 is also None.\\
& & unknown\_float\_2 & Unknown float. May be None is unknown\_float\_1 is also None.\\
& & keep\_bounding\_box & Bool. Whether to create a bounding box on export.\\
& & keep\_bounding\_sphere & Bool. Whether to create a bounding sphere on export.\\
\hline
add\_camera & CameraInterface & node\_id & Node that the CameraInterface should be attached to.\\
& & view\_matrix & A row-major 4x4 transform matrix represented as a flat list of 16 elements.\\
& & zNear & The near clip distance.\\
& & zFar & The far clip distance.\\
& & fov & The Field of View in degrees.\\
& & aspect\_ratio & The aspect ratio.\\
& & unknown\_0x50 & Unknown float.\\
\hline
add\_light & LightInterface & node\_id & Node that the LightInterface should be attached to.\\
& & type & 1 = Type1, 2 = Sphere, 3 = Hemisphere.\\
& & color\_1 & A 4-vector representing an RGBA color. Apparently unused.\\
& & color\_2 & A 4-vector representing an RGBA color. Main light color.\\
& & color\_3 & A 4-vector representing an RGBA color. Apparently unused.\\
\hline
add\_epl & EPLInterface & node\_id & Node that the EPL should be attached to.\\
& & binary & An EPLBinary object. \textbf{You can create EPLBinaries manually, but it is recommended to consider this function off-limits for creating new EPLs}.\\
\hline
add\_node & NodeInterface & parent\_idx & Index of the NodeInterface's parent NodeInterface.\\
 & & position & 3D position vector.\\
 & & rotation & XYZW quaternion.\\
 & & scale & 3D scale vector.\\
 & & unknown\_float & Unknown.\\
 & & bind\_pose\_matrix & A row-major 4x4 transform matrix represented as a flat list of 16 elements.\\
\hline
add\_material & MaterialInterface & name & The material name.\\
\hline
add\_texture & TextureInterface & name & The texture name.\\
& & data & A bytes-like object representing raw data for a DDS file.\\
& & unknown\_1 & Unknown int. Usually 1.\\
& & unknown\_2 & Unknown int. Usually 1.\\
& & unknown\_3 & Unknown int. Usually 0.\\
& & unknown\_4 & Unknown int. Usually 0.\\
\hline
\end{longtable}
\end{center}

\textbf{TODO: Description of each Interface}

\subsubsection{EPL}
\textbf{TODO}

\subsection{Blender Script Usage}
\label{SECTION::UsingAsABlenderPlugin}
Most Blender scripts will need to begin by importing the \textbf{bpy} module.
\begin{lstlisting}[style=pythonstyling]
import bpy
\end{lstlisting}

If you are writing a script outside of Blender, you will also need to add the \textbf{BlenderToolsForGFS} module to your import path (or create your python script in the same directory as a copy of the BlenderToolsForGFS library), and then import and register the module with Blender by calling the module's \textbf{register()} method.
\begin{lstlisting}[style=pythonstyling]
import BlenderToolsForGFS
BlenderToolsForGFS.register()
\end{lstlisting}

After the module is registered, you can import and export data using the operators that the plugin adds for these purposes.
\begin{lstlisting}[style=pythonstyling]
bpy.ops.import_file.import_gfs(filepath=...)
bpy.ops.import_file.import_gap(filepath=..., armature_name=...)

# Need to select the armature in order to use export functions
bpy.data.objects[...].select_set(True)

bpy.ops.export_file.export_gfs(filepath=...)
bpy.ops.export_file.export_gap(filepath=...)
\end{lstlisting}

These operators have the following keyword arguments:
\begin{center}
\begin{tabular}{p{.2\textwidth}p{.1\textwidth}p{.69\textwidth}}
\hline
\multicolumn{3}{c}{import\_gfs}\\
Keyword & Type & Description\\
\hline
filepath & string & The filepath to the file to import.\\
set\_fps & bool & Switches Blender animation to 30 FPS. Default: False.\\
debug\_mode & bool & Allows exceptions to be raised instead of silently suppressed by popup windows. Default: False.\\
merge\_vertices & bool & Attempts to create a manifold mesh out of the input vertices. Default: True.\\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{p{.2\textwidth}p{.1\textwidth}p{.69\textwidth}}
\hline
\multicolumn{3}{c}{import\_gap}\\
Keyword & Type & Description\\
\hline
filepath & string & The filepath to the file to import.\\
set\_fps & bool & Switches Blender animation to 30 FPS. Default: False.\\
debug\_mode & bool & Allows exceptions to be raised instead of silently suppressed by popup windows. Default: False.\\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{p{.2\textwidth}p{.1\textwidth}p{.69\textwidth}}
\hline
\multicolumn{3}{c}{export\_gfs}\\
Keyword & Type & Description\\
\hline
filepath & string & The filepath to the file to import.\\
version & string & The file version to export as. Default: 0x01105100.\\
debug\_mode & bool & Allows exceptions to be raised instead of silently suppressed by popup windows. Default: False.\\
pack\_animations & bool & Whether to pack animations into the model or not. Default: False.\\
\hline
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{p{.2\textwidth}p{.1\textwidth}p{.69\textwidth}}
\hline
\multicolumn{3}{c}{export\_gap}\\
Keyword & Type & Description\\
\hline
filepath & string & The filepath to the file to import.\\
version & string & The file version to export as. Default: 0x01105100.\\
debug\_mode & bool & Allows exceptions to be raised instead of silently suppressed by popup windows. Default: False.\\
\hline
\end{tabular}
\end{center}

\textbf{TODO: Custom PropertyGroups}
\clearpage

\section{Future Development}
Listed here are a few directions that future development could go. This is not a promise of feature development; just an inexhaustive record of ideas for any contributors who might want to improve the tools in some fashion.
\subsection{Blender Interface}
\begin{itemize}
\item Create an accurate Shader Node for GFS materials. This will require the material data structures to be fully researched beforehand.
\item Redesign the animation import/export so that more than just node animations can be imported. Material animations would need to be somehow linked to a corresponding node animation, and so forth. An idea on how to do this would be to have a list of exported animations on the animation pack, and each animation entry can contain a \textbf{CollectionProperty} of \textbf{PointerProperties} to \textbf{bpy.types.Action}s. Each animation can additionally have a checkbox next to it that will mute or unmute \textbf{bpy.types.Action}s that are linked to it simultaneously, so that the user does not have to indivudually unmute every animation on every object to preview the entire animation.
\item Related to the above: a \textbf{CollectionProperty} of Animation Packs could be implemented so that multiple Animation Packs can be imported and exported. Since we would already be collecting exported animations into a \textbf{CollectionProperty}, that would just mean that each AnimationPack would be in charge of its own \textbf{CollectionProperty} of animations.
\item After the previous points are implemented and are guaranteed to work well both technically and from a user's perspective, then material, camera, and morph animations can be added.
\item Physics colliders and joint physics can be imported as meshes with rigid body physics and a bunch of properties. Buttons to generate these meshes can be added to a menu somewhere.
\item EPL submodels should be imported into the scene tree too, but only after the animation and material refactors have been implemented.
\item GFS Properties could be turned into a group of settings instead of an arbitrary list (or both could be available). For example, any Properties required to create collision triggers could be added with a subpanel rather than asking the user to copy out a list of collision properties. However, the various sets of properties would have to first be researched and property understood.
\item The vertex-merging algorithm should be refactored to work by merging vertices such that \textbf{any face} will not be removed, rather than just checking if there are two overlapping antiparallel faces.
\end{itemize}

\subsection{Python API}
\begin{itemize}
\item RootNodes should be moved out of the node list. Any parentless nodes in the GFS node list should be automatically parented to the RootNode, which must always exist by construction. Currently the GFSInterface is fragile, in the sense that if the first node is \textit{not} the root node, everything explodes.
\item Cameras need a proper Interface.
\item Lights need a proper Interface.
\item The AnimationInterface needs to be more cleanly designed: it currently has a lot of awkward heuristics to serialise node animations and can duplicate tracks and so forrth due to a lack of understanding of how all the animation keys work.
\end{itemize}

\clearpage

\section{Technical Details}
\subsection{Scene Graph Importing and Animation}

For our purposes, we will define a \textbf{Scene Graph} as having the following properties:
\begin{enumerate}
\item A \textbf{Scene Graph} is a \textbf{Directed Acyclic Graph} consisting of \textbf{Directed Edges} and \textbf{Scene Nodes}.
\item It has a single \textbf{root} or \textbf{origin node}, which may be implicit.
\item 
\end{enumerate}


\subsubsection{Basic Transform Matrix Definitions and Identities}
\paragraph{3D Homogeneous Coordinates}\mbox{}\\
3D homogeneous coordinates are an embedding of 3D transforms into 4D space, with the fourth dimension typically treated in a unitary fashion. For example, a 3D position vector becomes
\begin{equation}
v = \begin{pmatrix}
a\\
b\\
c\\
1
\end{pmatrix},
\end{equation}
a 3D directional vector becomes
\begin{equation}
v = \begin{pmatrix}
a\\
b\\
c\\
0
\end{pmatrix},
\end{equation}
and a 3D matrix becomes
\begin{equation}
M =
\begin{pmatrix}
m_{11} & m_{12} & m_{13} & 0\\
m_{21} & m_{22} & m_{23} & 0\\
m_{31} & m_{32} & m_{33} & 0\\
0 & 0 & 0 & 1
\end{pmatrix}.
\end{equation}
We will use this coordinate system not only because it is the coordinate system used both by the GFS models and by Blender, but also because it allows us to represent translations as matrices on the same footing as rotations and scales.

\paragraph{Translation Matrices}\mbox{}\\
We define a 3D transformation matrix as
\begin{equation}
T = \begin{pmatrix}
1 & 0 & 0 & t_x\\
0 & 1 & 0 & t_y\\
0 & 0 & 1 & t_z\\
0 & 0 & 0 & 1
\end{pmatrix}.
\end{equation}
This has three degrees of freedom in $t_x$, $t_y$, and $t_z$. These represent translations in the $x$, $y$, and $z$ dimensions respectively.

We note that the inverse of a translation matrix is also a translation matrix, and that it always exists:
\begin{equation}
T^{-1} = T' = \begin{pmatrix}
1 & 0 & 0 & -t_x\\
0 & 1 & 0 & -t_y\\
0 & 0 & 1 & -t_z\\
0 & 0 & 0 & 1
\end{pmatrix}.
\end{equation}
\paragraph{Rotation Matrices}\mbox{}\\
We define a 3D rotation matrix as having the following form:
\begin{equation}
R = \begin{pmatrix}
r_{11} & r_{12} & r_{13} & 0\\
r_{21} & r_{22} & r_{23} & 0\\
r_{31} & r_{32} & r_{33} & 0\\
0 & 0 & 0 & 1
\end{pmatrix}.
\end{equation}
In addition, a rotation matrix is a \textbf{special orthogonal matrix}, \textit{i.e.} it both obeys orthogonality
\begin{equation}
R^T R = I,
\end{equation}
and has determinant 1,
\begin{equation}
\det R = 1.
\end{equation}
We will not prove this here, but this also constrains a rotation matrix to three degrees of freedom, which can be decomposed as (for example)
\begin{itemize}
\item A rotation around the X, Y, and Z axes,
\item A quaternion constrained to have a norm of 1.
\end{itemize}
We note that the inverse of a rotation matrix is also a rotation matrix, and that it always exists:
\begin{equation}
R^{-1} = R^T = R' =  \begin{pmatrix}
r_{11} & r_{21} & r_{31} & 0\\
r_{12} & r_{22} & r_{32} & 0\\
r_{13} & r_{23} & r_{33} & 0\\
0 & 0 & 0 & 1
\end{pmatrix}.
\end{equation}
\paragraph{Scale Matrices}\mbox{}\\
We define a 3D scale matrix as having the following form:
\begin{equation}
S = \begin{pmatrix}
s_{x} & 0 & 0 & 0\\
0 & s_y & 0 & 0\\
0 & 0 & s_z & 0\\
0 & 0 & 0 & 1
\end{pmatrix},
\end{equation}
which again has three degrees of freedom in $s_x$, $s_y$, and $s_z$, which are the scale factors in the $x$, $y$, and $z$ dimensions.
\textbf{A scale matrix is not guaranteed to have an inverse}, but if it exists, it is also a scale matrix:
\begin{equation}
S^{-1} = S' = \begin{pmatrix}
\frac{1}{s_x} & 0 & 0 & 0\\
0 & \frac{1}{s_y} & 0 & 0\\
0 & 0 & \frac{1}{s_z} & 0\\
0 & 0 & 0 & 1
\end{pmatrix},
\end{equation}
which does not exist if any of $s_x$, $s_y$, or $s_z$ are 0.

\paragraph{Combinations of transforms}\mbox{}\\
Having defined our three basic types of transformation matrix, we can now see how they interact with each other. There are nine different products we can take of these three transforms:
\begin{center}
\begin{tabular}{|c|ccc|}
\hline
& $T$ & $R$ & $S$ \\
\hline
$T$ & $TT$ & $TR$ & $TS$ \\
$R$ & $RT$ & $RR$ & $RS$ \\
$S$ & $ST$ & $SR$ & $SS$ \\
\hline
\end{tabular}
\end{center}
We will need to manipulate all of these products in the following sections, so let us prove some basic facts about them.\\

\noindent
\textit{Lemma.} \textbf{A product of a two translation matrices is also a translation matrix.}
\begin{equation}
T_1 T_2 = T_3.
\end{equation}
\noindent
\textit{Proof.} 
\begin{align}
M &= T_1T_2 \\
&=
\begin{pmatrix}
1 & 0 & 0 & t_{x, 1}\\
0 & 1 & 0 & t_{y, 1}\\
0 & 0 & 1 & t_{z, 1}\\
0 & 0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
1 & 0 & 0 & t_{x, 2}\\
0 & 1 & 0 & t_{y, 2}\\
0 & 0 & 1 & t_{z, 2}\\
0 & 0 & 0 & 1
\end{pmatrix}\\
&= 
\begin{pmatrix}
1 & 0 & 0 & t_{x, 1} + t_{x, 2}\\
0 & 1 & 0 & t_{y, 2} + t_{y, 2}\\
0 & 0 & 1 & t_{z, 2} + t_{z, 2}\\
0 & 0 & 0 & 1
\end{pmatrix}\\
&= T_3.
\end{align}
\noindent
\textit{Lemma.}\textbf{ A product of a rotation and a translation matrix can be decomposed to a product of a distinct translation and the same rotation matrix.}
\begin{equation}
R T_1 = T_2 R
\end{equation}

\noindent\textit{Proof.}
\begin{align}
M &= RT_1 \\
&=
\begin{pmatrix}
r_{11} & r_{12} & r_{13} & 0\\
r_{21} & r_{22} & r_{23} & 0\\
r_{31} & r_{32} & r_{33} & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
1 & 0 & 0 & t_x\\
0 & 1 & 0 & t_y\\
0 & 0 & 1 & t_z\\
0 & 0 & 0 & 1
\end{pmatrix}\\
&=
\begin{pmatrix}
r_{11} & r_{12} & r_{13} & r_{11}t_x + r_{12}t_y + r_{13}t_z\\
r_{21} & r_{22} & r_{23} & r_{21}t_x + r_{22}t_y + r_{23}t_z\\
r_{31} & r_{32} & r_{33} & r_{31}t_x + r_{32}t_y + r_{33}t_z\\
0 & 0 & 0 & 1
\end{pmatrix}\\
&=
\begin{pmatrix}
1 & 0 & 0 & r_{11}t_x + r_{12}t_y + r_{13}t_z\\
0 & 1 & 0 & r_{21}t_x + r_{22}t_y + r_{23}t_z\\
0 & 0 & 1 & r_{31}t_x + r_{32}t_y + r_{33}t_z\\
0 & 0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
r_{11} & r_{12} & r_{13} & 0\\
r_{21} & r_{22} & r_{23} & 0\\
r_{31} & r_{32} & r_{33} & 0\\
0 & 0 & 0 & 1
\end{pmatrix}\\
&= T_2 R
\end{align}

\noindent
\textit{Lemma.}\textbf{ A product of a scale and a translation matrix can be decomposed to a product of a distinct translation and the same scale matrix.}
\begin{equation}
S T_1 = T_2 S
\end{equation}

\noindent\textit{Proof.}
\begin{align}
M &= ST_1 \\
&=
\begin{pmatrix}
s_x & 0 & 0 & 0\\
0 & s_y & 0 & 0\\
0 & 0 & s_z & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
1 & 0 & 0 & t_x\\
0 & 1 & 0 & t_y\\
0 & 0 & 1 & t_z\\
0 & 0 & 0 & 1
\end{pmatrix}\\
&=
\begin{pmatrix}
s_x & 0 & 0 & s_x t_x\\
0 & s_y & 0 & s_y t_y\\
0 & 0 & s_z & s_z t_z\\
0 & 0 & 0 & 1
\end{pmatrix}\\
&=
\begin{pmatrix}
1 & 0 & 0 & s_x t_x\\
0 & 1 & 0 & s_y t_y\\
0 & 0 & 1 & s_z t_z\\
0 & 0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
s_x & 0 & 0 & 0\\
0 & s_y & 0 & 0\\
0 & 0 & s_z & 0\\
0 & 0 & 0 & 1
\end{pmatrix}\\
&= T_2 S
\end{align}

\noindent
\textit{Lemma.}\textbf{ A product of two rotation matrices is another rotation matrix.}
\begin{equation}
R_1 R_2 = R_3
\end{equation}

\noindent\textit{Proof.}
We begin by proving that the product $R_1 R_2$ is orthogonal.
\begin{align}
M^T M &= (R_1 R_2)^T (R_1 R_2)\\
 &= R_2^T R_1^T R_1 R_2\\
 &= R_2^T R_2\\
 &= 1.
\end{align}

We now prove that the determinant remains 1. For square matrices, it is known that
\begin{equation}
\det(AB) = \det(A)\det(B),
\end{equation}
which tells us
\begin{align}
\det(M) &= \det(R_1 R_2)\\
 &= \det(R_1)\det(R_2)\\
 &= 1 \times 1\\
 &= 1.
\end{align}

We therefore see that $M$ is both orthogonal and has determinant 1, and so we can identify it as a rotation matrix.\\

\noindent
\textit{Lemma.}\textbf{ A product of a scale matrix and a rotation matrix cannot, generally, be decomposed to a different product of translations, rotations, and scales.}

\noindent\textit{Proof.}
\begin{align}
S R &= \begin{pmatrix}
s_x & 0 & 0 & 0\\
0 & s_y & 0 & 0\\
0 & 0 & s_z & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
r_{11} & r_{12} & r_{13} & 0\\
r_{21} & r_{22} & r_{23} & 0\\
r_{31} & r_{32} & r_{33} & 0\\
0 & 0 & 0 & 1
\end{pmatrix}\\
&= \begin{pmatrix}
s_x r_{11} & s_x r_{12} & s_x r_{13} & 0\\
s_y r_{21} & s_y r_{22} & s_y r_{23} & 0\\
s_z r_{31} & s_z r_{32} & s_z r_{33} & 0\\
0 & 0 & 0 & 1
\end{pmatrix}\\
&= \begin{pmatrix}
\frac{s_x}{s'_x} r_{11} & \frac{s_x}{s'_y} r_{12} & \frac{s_x}{s'_z} r_{13} & 0\\
\frac{s_y}{s'_x} r_{21} & \frac{s_y}{s'_y} r_{22} & \frac{s_y}{s'_z} r_{23} & 0\\
\frac{s_z}{s'_x} r_{31} & \frac{s_z}{s'_y} r_{32} & \frac{s_z}{s'_z} r_{33} & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
s'_x & 0 & 0 & 0\\
0 & s'_y & 0 & 0\\
0 & 0 & s'_z & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
\end{align}
In the final line we have separated out a scale matrix on the right, but the left factor is not obviously orthogonal. To orthoganalise this factor, we know that a general matrix can be decomposed into an orthognal matrix and an upper-triangular matrix with the $QR$ decomposition. Here, we will denote the orthogonal matrix as $R'$ rather than $Q$, and the upper-triangular as $H$ rather than $R$. We can also state that we can extract whichever reflection matrix makes $R'$ special orthogonal such that it is a proper rotation, move this through the upper-triangular matrix, and absorb it into the definition of the new scale matrix.
\begin{align}
S R &= R' H S'\\
&= \begin{pmatrix}
r'_{11} & r'_{12} & r'_{13} & 0\\
r'_{21} & r'_{22} & r'_{23} & 0\\
r'_{31} & r'_{32} & r'_{33} & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
\begin{pmatrix}
1 & h_{xy} & h_{xz} & 0\\
0 &      1 & h_{yz} & 0\\
0 &      0 &      1 & 0\\
0 &      0 &      0 & 1
\end{pmatrix}
\begin{pmatrix}
s'_x & 0 & 0 & 0\\
0 & s'_y & 0 & 0\\
0 & 0 & s'_z & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
\end{align}
We can find the values of the new rotation matrix \textit{via}
\begin{align}
R'HS' &= SRS'^{-1} H^{-1} H S'\\
\Rightarrow R' &= S R S'^{-1} H^{-1}\\
&= \begin{pmatrix}
\frac{s_x}{s'_x} r_{11} & - h_{xy} \frac{s_x}{s'_x} r_{11} + \frac{s_x}{s'_y} r_{12} & - \widetilde{h} \frac{s_x}{s'_x} r_{11} - h_{yz} \frac{s_x}{s'_y} r_{12} + \frac{s_x}{s'_z} r_{13} & 0\\
\frac{s_y}{s'_x} r_{21} & -h_{xy} \frac{s_y}{s'_x} r_{21} + \frac{s_y}{s'_y} r_{22} &  - \widetilde{h} \frac{s_y}{s'_x} r_{21} - h_{yz} \frac{s_y}{s'_y} r_{22} + \frac{s_y}{s'_z} r_{23} & 0\\
\frac{s_z}{s'_x} r_{31} & -h_{xy} \frac{s_z}{s'_x} r_{31} + \frac{s_z}{s'_y} r_{32} &  - \widetilde{h} \frac{s_z}{s'_x} r_{31} - h_{yz} \frac{s_z}{s'_y} r_{32}  + \frac{s_z}{s'_z} r_{33} & 0\\
0 & 0 & 0 & 1
\end{pmatrix}
\end{align}
where $\widetilde{h} = h_{xz} - h_{xy}h_{yz}$.

However, we need to eliminate the matrix $H$. If we can do this, we will need to show that the values of $h_{xy}$, $h_{xz}$, and $h_{yz}$ are 0.

The orthonormality of $R'$ gives us six constraints. For a given $R$ and $S$, we have six unknowns - $h_{xy}$, $h_{xz}$, $h_{yz}$, $s'_x$, $s'_y$, and $s'_z$. We should therefore be able to solve for these six variables.

To obtain our conditions, we will impose the fact that $R'$ must be orthogonal by taking
\begin{equation}
R'^T R' = 1.
\end{equation}
Note that we have very carefully decided to take the product $R'^T R'$ rather than $R' R'^T$: as we will see, this immediately gives us some exactly solvable equations that we can bootstrap the remaining unknowns from. It might be expected that we would get nine equations from this product; the product is, however, a symmetric matrix---and thus we obtain identical contraints from opposing off-diagonal elements.

Let us label the columns of $R'$ as $v_1$, $v_2$, and $v_3$ from left-to-right. Orthognality requires the following conditions to be true:
\begin{align}
\label{EQUATION::ShearV1V1} v_1 \cdot v_1 &= 1\\
\label{EQUATION::ShearV2V1} v_2 \cdot v_1 &= 0 (= v_1 \cdot v_2)\\
\label{EQUATION::ShearV2V2} v_2 \cdot v_2 &= 1\\
\label{EQUATION::ShearV3V1} v_3 \cdot v_1 &= 0(= v_1 \cdot v_3)\\
\label{EQUATION::ShearV3V2} v_3 \cdot v_2 &= 0(= v_2 \cdot v_3)\\
\label{EQUATION::ShearV3V3} v_3 \cdot v_3 &= 1,
\end{align}
which we obtain by inspecting the elements of the unit matrix the product $R'^T R'$ is equal to.

These equations are ordered in increasing complexity, and by inspecting them in order we will obtain results that can be used to simplify later equations. We therefore begin with equation (\ref{EQUATION::ShearV1V1}). This contains only a single unknown, and so we can directly solve it.
\begin{equation}
\label{EQUATION::ShearV1V1Expanded} 
\left(\frac{s_x}{s'_x} r_{11}\right)^2 + \left(\frac{s_y}{s'_x} r_{21}\right)^2 +\left(\frac{s_z}{s'_x} r_{31}\right)^2  = 1.
\end{equation}
This itself will be a useful result, but we can already just multiply through by ${s'_x}^2$ to solve for ${s'_x}^2$ as
\begin{equation}
s'_x = \left(s_x r_{11}\right)^2 + \left(s_y r_{21}\right)^2 +\left(s_z r_{31}\right)^2.
\end{equation}

Next are equations (\ref{EQUATION::ShearV2V1}) and (\ref{EQUATION::ShearV2V2}). These feature the same two unknowns (excluding $s'_x$, which we now know) and we should expect to solve them simultaneously. We begin with (\ref{EQUATION::ShearV2V1}):
\begin{align}
\begin{multlined}[b]
r_{11}\frac{s_x}{s'_x} \left( -h_{xy} \frac{s_x}{s'_x} r_{11} + \frac{s_x}{s'_y} r_{12} \right) 
+ r_{21}\frac{s_y}{s'_x} \left( -h_{xy} \frac{s_y}{s'_x} r_{21} + \frac{s_y}{s'_y} r_{22} \right) \\
+ r_{31}\frac{s_z}{s'_x} \left( -h_{xy} \frac{s_z}{s'_x} r_{31} + \frac{s_z}{s'_y} r_{32} \right)
\end{multlined} &= 0\\
\label{EQUATION::ShearXYStep2} \begin{multlined}[b]
-h_{xy} \left( \underbrace{ \left(\frac{s_x}{s'_x}r_{11}\right)^2 +  \left(\frac{s_y}{s'_x}r_{21}\right)^2 +  \left(\frac{s_z}{s'_x}r_{31}\right)^2 }_{1} \right) + \\
\left( \frac{s_x^2}{s'_x s'_y}r_{11}r_{12} + \frac{s_y^2}{s'_x s'_y}r_{21}r_{22} + \frac{s_z^2}{s'_x s'_y}r_{31}r_{32} \right)
\end{multlined} &= 0\\
\label{EQUATION::ShearXYResult} \Rightarrow h_{xy} =  \frac{s_x^2}{s'_x s'_y}r_{11}r_{12} + \frac{s_y^2}{s'_x s'_y}r_{21}r_{22} + \frac{s_z^2}{s'_x s'_y}r_{31}r_{32}
\end{align}
where in (\ref{EQUATION::ShearXYStep2}) we used (\ref{EQUATION::ShearV1V1Expanded}) to simplify the result. We have now identified $h_{xy}$, and move on to equation (\ref{EQUATION::ShearV2V2}):
\begin{align}
-h_{xy}
\end{align}

\clearpage
\subsubsection{Bone/Node Animations}
We will need to match the Blender animation equation to the GFS animation equation in order to import animations. We will start by considering just the bone animations, and leave vertex animations until we have determined these.

GFS node animations are given by
\begin{equation}
A_\mathrm{GFS}  = \left( \prod_i \left(T_\mathrm{base} T_A\right) \cdot \left(R_\mathrm{base} R_A\right) \cdot \left(S_\mathrm{base} + S_A\right) \right)
\end{equation}
where
\begin{itemize}
\item $T_\mathrm{base}$ is the base parent-relative translation matrix, taken from the currently-active ``normal" animation (or the rest pose if undefined by the animation).
\item $T_\mathrm{A}$ is the translation defined by a Blend animation. An arbitrary number of $T_A$s, including 0, can be applied to the right of $T_\mathrm{base}$.
\item $R_\mathrm{base}$ is the base parent-relative rotation matrix, taken from the currently-active ``normal" animation (or the rest pose if undefined by the animation).
\item $R_\mathrm{A}$ is the rotation defined by a Blend animation. An arbitrary number of $R_A$s, including 0, can be applied to the right of $R_\mathrm{base}$.
\item $S_\mathrm{base}$ is the base parent-relative scale matrix, taken from the currently-active ``normal" animation (or the rest pose if undefined by the animation).
\item $S_\mathrm{A}$ is the scale defined by a Blend animation. An arbitrary number of $S_A$s, including 0, can be applied to the right of $S_\mathrm{base}$. Note that the Blend scale matrices have a 0 in the bottom-right corner of the transformation matrix rather than the typical 1. Equivalently, you can consider the scale vectors to be summed before being converted to a translation matrix.
\end{itemize}
We also need to bear in mind the following conventions:
\begin{itemize}
\item Rotations are relative to the $X$-axis.
\item The coordinate system is a right-handed, Y-up coordinate system.
\end{itemize}
In contrast to the GFS animation equation,
\begin{itemize}
\item Rotations are relative to the $Y$-axis.
\item The coordinate system is a right-handed, Z-up coordinate system.
\item Bone animations are relative to a \textbf{local bind pose transform}, not the \textbf{parent transform}.
\end{itemize}

The \textbf{local bind pose} is the transformation from the \textbf{bone's parent bind pose} to the \textbf{bone's bind pose}. A \textbf{bind pose} is a Translation-Rotation matrix providing an anchor point for vertices weighted to the bone to be deformed relative to,
\begin{equation}
M_\mathrm{BP} = T_\mathrm{BP}R_\mathrm{BP},
\end{equation}
and we mathematically denote the local bind pose as
\begin{align}
M_\mathrm{BPL} &= \left(M^\mathrm{P}_\mathrm{BP}\right)^{-1} M_\mathrm{BP}\\
 &=  \left(T_\mathrm{BP}^\mathrm{P} R_\mathrm{BP}^\mathrm{P}\right)^{-1} T_\mathrm{BP}R_\mathrm{BP}\\
 &= \left(R_\mathrm{BP}^\mathrm{P}\right)^{-1} \left(T_\mathrm{BP}^\mathrm{P}\right)^{-1} T_\mathrm{BP}R_\mathrm{BP}\\
 &=  T_\mathrm{BPL} \left(R_\mathrm{BP}^\mathrm{P}\right)^{-1} R_\mathrm{BP}\\
 &=  T_\mathrm{BPL} R_\mathrm{BPL}
\end{align}
which defines
\begin{align}
T_\mathrm{BPL} &= \left(R_\mathrm{BP}^\mathrm{P}\right)^{-1} \left(T_\mathrm{BP}^\mathrm{P}\right)^{-1} T_\mathrm{BP} R_\mathrm{BP}^\mathrm{P}\\
R_\mathrm{BPL} &= \left(R_\mathrm{BP}^\mathrm{P}\right)^{-1} R_\mathrm{BP}
\end{align}
However, we note that bones with no parents are a \textbf{special case} where
\begin{equation}
M_\mathrm{BPL} = M_\mathrm{BP}.
\end{equation}

We have three main steps we need to take in order to convert the GFS animation to Blender animations:
\begin{itemize}
\item Convert the transforms from parent-relative to bind-relative,
\item Convert the rotations from $X$-axis relative to $Y$-axis relative,
\item Convert the transforms from a right-handed Y-up coordinate system to a right-handed Z-up coordinate system.
\end{itemize}
In order to maintain alignment with the GFS animation system, we furthermore require the following:
\begin{itemize}
\item The Rest Pose is implemented as a single-frame bind-relative animation that is always active and at the bottom of the NLA editor order,
\item Normal Animations are bind-relative animations using \textbf{REPLACE} strip blending and have higher priority than the Rest Pose in the NLA editor,
\item Blend Animations use the \textbf{COMBINE} strip blending for translation and rotations, and \textbf{ADD} strip blending for scale channels, and have higher priority than Normal animations in the NLA editor.
\end{itemize}

With these strip blending types and priority ordering, we can create the following animation equation in Blender:
\begin{equation}
A_\mathrm{Blender} = \left( \prod_i {M}_\mathrm{BPL} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \right) M_\mathrm{BP}^{-1}
\end{equation}

We can then match GFS animations to Blender equations by requiring that
\begin{equation}
A_\mathrm{Blender} = A_\mathrm{GFS} M^{-1}_\mathrm{BP}
\end{equation}
and calculating the transformation rules for our three transformation conditions.

\paragraph{Parent-relative to bind-relative transformations}\mbox{}\\
We will start from $A = A_\mathrm{GFS} M^{-1}_\mathrm{BP}$ and determine how to reshape this equation into a Blender-compatible form.
\begin{align}
A &= \left( \prod_i \left(T_\mathrm{base} T_A\right) \cdot \left(R_\mathrm{base} R_A\right) \cdot \left(S_\mathrm{base} + S_A\right) \right) M_\mathrm{BP}^{-1}\\
 &= \left( \prod_i M_\mathrm{BPL} M_\mathrm{BPL}^{-1} \left(T_\mathrm{base} T_A\right) \cdot \left(R_\mathrm{base} R_A\right) \cdot \left(S_\mathrm{base} + S_A\right) \right) M_\mathrm{BP}^{-1}\\
  &= \left( \prod_i M_\mathrm{BPL} R_\mathrm{BPL}^{-1} T_\mathrm{BPL}^{-1} \left(T_\mathrm{base} T_A\right) \cdot \left(R_\mathrm{base} R_A\right) \cdot \left(S_\mathrm{base} + S_A\right) \right) M_\mathrm{BP}^{-1}
\end{align}
Define $T_\mathrm{offset} = T^{-1}_\mathrm{BPL} T_\mathrm{base}$,
\begin{equation}
A  = \left( \prod_i M_\mathrm{BPL} R_\mathrm{BPL}^{-1} \left(T_\mathrm{offset} T_A\right) \cdot \left(R_\mathrm{base} R_A\right) \cdot \left(S_\mathrm{base} + S_A\right) \right) M_\mathrm{BP}^{-1}
\end{equation}
We now need to absorb the $R^{-1}_\mathrm{BPL}$ factor into the rotation matrices. We can use the fact that $R^{-1} = R'$ and that $RT = T'R$ to move the rotation matrices past the translation matrices. We can equivalently note that $RT = T'R \Rightarrow T = R^{-1}TR$, and use this fact to insert factors of $R_\mathrm{BPL}R^{-1}_\mathrm{BPL} = 1$ into the equation in order to generate redefined translation matrices. 
\begin{align}
A  &= 
\begin{multlined}[t]
\Bigg( \prod_i M^L_\mathrm{BP} R_\mathrm{BPL}^{-1} \left(T_\mathrm{offset} R_\mathrm{BPL}R_\mathrm{BPL}^{-1}T_A R_\mathrm{BPL}R_\mathrm{BPL}^{-1}\right) \\
\hspace{130pt}  \cdot \left(R_\mathrm{base} R_A\right) \cdot \left(S_\mathrm{base} + S_A\right) \Bigg) M_\mathrm{BP}^{-1}
\end{multlined}\\
 &= \begin{multlined}[t]
\Bigg( \prod_i M^L_\mathrm{BP} \left( R_\mathrm{BPL}^{-1} T_\mathrm{offset} R_\mathrm{BPL}\right)\left( R_\mathrm{BPL}^{-1}T_A R_\mathrm{BPL}\right) \cdot \\
\hspace{110pt} \left(R_\mathrm{BPL}^{-1}  R_\mathrm{base} R_A\right) \cdot \left(S_\mathrm{base} + S_A\right) \Bigg) M_\mathrm{BP}^{-1}
\end{multlined}
\end{align}
Since we know that the products $R^{-1}_\mathrm{BPL} T R_\mathrm{BPL}$ are themselves translation matrices, and that the product of two rotation matrices is another rotation matrix, we can now identity
\begin{align}
T_1 &= R_\mathrm{BPL}^{-1} T_\mathrm{offset} R_\mathrm{BPL}\\
T_2 &= R_\mathrm{BPL}^{-1} T_A R_\mathrm{BPL}\\
R_1 &= R_\mathrm{BPL}^{-1} R_\mathrm{base}\\
R_2 &= R_A\\
S_1 &= S_\mathrm{base}\\
S_2 &= S_a
\end{align}

\paragraph{Axis Permutations}\mbox{}\\
Consider the case where we take ${M}_\mathrm{BP} \to {M}_\mathrm{BP} P_\mathrm{axis} \triangleq {M}_\mathrm{BPA}$. We note that since, for non-root bones, 
\begin{equation}
{M}_\mathrm{BPL} = \left({M}_\mathrm{BPL}^\mathrm{P}\right)^{-1} {M}_\mathrm{BP},
\end{equation}
the local bind pose will transform as
\begin{align}
{M}_\mathrm{BPL}  &\to P_\mathrm{axis}^{-1} \left({M_i}_\mathrm{BP}^\mathrm{P}\right)^{-1} {M_i}_\mathrm{BP} P_\mathrm{axis} \\
&\to P_\mathrm{axis}^{-1}{M_i}_\mathrm{BPL} P_\mathrm{axis}
\end{align}
For convenience we will define this is the \textbf{A}xis-permuted \textbf{L}ocal \textbf{B}ind \textbf{P}ose matrix,
\begin{equation}
P_\mathrm{axis}^{-1}M_\mathrm{BPL} P_\mathrm{axis} \triangleq M_\mathrm{BPLA}.
\end{equation}
However, for the root bone, we have that
\begin{equation}
{M_0}_\mathrm{BPL} = {M_0}_\mathrm{BP}
\end{equation}
and so the transformation rule is instead
\begin{equation}
{M_0}_\mathrm{BPL} \to {M_0}_\mathrm{BPL} P_\mathrm{axis}.
\end{equation}
Following our previous conventions, we define this as
\begin{equation}
{M_0}_\mathrm{BPL} P_\mathrm{axis} \triangleq {M_0}_\mathrm{BPLA} = {M_0}_\mathrm{BPA}.
\end{equation}
We should therefore expect to treat the root node differently to other nodes.

In order switch from using $M_\mathrm{BP}$ and $M_\mathrm{BPL}$ to  $M_\mathrm{BPA}$ and $M_\mathrm{BPLA}$ whilst leaving the overall animation invariant, we will insert factors of $P_\mathrm{axis}^{-1}P_\mathrm{axis}$---this product being just a unit matrix---into the animation equation in a manner that allows us to factor out the axis-permuted versions of the bind pose matrices.

We'll start by taking the Blender animation equation for a bone, and separating out the root bone transforms.
\begin{align}
A &= \left( \prod_i {M_i}^L_\mathrm{BP} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \right) M_\mathrm{BP}^{-1}\\
 &= \!\begin{multlined}[t] \left( {M_0}^L_\mathrm{BP} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \right)\\
 \cdot \left( \prod_{i=1}^{i=N} {M_i}^L_\mathrm{BP} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \right) M_\mathrm{BP}^{-1}
\end{multlined}
\end{align}
We can then insert the relevant factors of $P_\mathrm{axis}P_\mathrm{axis}^{-1}$ that allows us to factorise out the axis-permuted bind poses as
\begin{align}
A &= \!\begin{multlined}[t] \left( {M_0}_\mathrm{BPL} P_\mathrm{axis}P_\mathrm{axis}^{-1} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \right)\\
 \cdot \left( \prod_{i=1}^{i=N}  P_\mathrm{axis} P_\mathrm{axis}^{-1} {M_i}_\mathrm{BPL}  P_\mathrm{axis} P_\mathrm{axis}^{-1} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \right)\\
 \cdot P_\mathrm{axis} P_\mathrm{axis}^{-1} M_\mathrm{BP}^{-1}
\end{multlined}\\
&= \!\begin{multlined}[t] \left( {M_0}_\mathrm{BPLA} P_\mathrm{axis}^{-1} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \right)\\
 \cdot \left( \prod_{i=1}^{i=N}  P_\mathrm{axis} {M_i}_\mathrm{BPLA}  P_\mathrm{axis}^{-1} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \right)
 \cdot P_\mathrm{axis} M_\mathrm{BPA}^{-1}
\end{multlined}
\end{align}
We are now left with the problem of removing the leftover permutation matrices. Since permutation matrices are a special case of a rotation matrix, if we can absorb them into the rotation matrices then we will be left with an animation equation with the same form as the Blender animation equation.

The first step we will take is recognising that if we insert a factor $P_\mathrm{axis}P_\mathrm{axis}^{-1}$ after the scaling factors for a bone, we will cancel out the $P_\mathrm{axis}$ at the front of the next term. On the final bone, this will cancel out the $P_\mathrm{axis}$ generated by factorising $M^{-1}_\mathrm{BP} \to M^{-1}_\mathrm{BPA}$.
\begin{align}
A &= \!\begin{multlined}[t] \left( {M_0}_\mathrm{BPLA} P_\mathrm{axis}^{-1} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \cdot \left(P_\mathrm{axis}P_\mathrm{axis}^{-1}\right)\right)\\
 \cdot \left( \prod_{i=1}^{i=N}  P_\mathrm{axis} {M_i}_\mathrm{BPLA}  P_\mathrm{axis}^{-1} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \cdot \left(P_\mathrm{axis}P_\mathrm{axis}^{-1}\right) \right)\\
 \cdot P_\mathrm{axis} M_\mathrm{BPA}^{-1}
\end{multlined}\\
&= \!\begin{multlined}[t] \left( {M_0}_\mathrm{BPLA} P_\mathrm{axis}^{-1} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \cdot P_\mathrm{axis}\right)\\
 \cdot \left( \prod_{i=1}^{i=N} {M_i}_\mathrm{BPLA}  P_\mathrm{axis}^{-1} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \cdot P_\mathrm{axis} \right) \cdot M_\mathrm{BPA}^{-1}
\end{multlined}\\
&= \left( \prod_{i} {M_i}_\mathrm{BPLA}  P_\mathrm{axis}^{-1} \left(T_1 T_2\right) \cdot \left(R_1 R_2\right) \cdot \left(S_1 + S_2\right) \cdot P_\mathrm{axis} \right) \cdot M_\mathrm{BPA}^{-1}
\end{align}
The bone transforms are now sandwiched between two permutation matrices. We can attack the matrix in front of the translation matrices in the same manner as we dealt with the rotation matrices in section \ref{}: we recognise that since $RT = T'R$, we can construct a translation matrix as $T=R^{-1}T'R$. Applying this strategy gives us
\begin{align}
A &= \begin{multlined}[t]
\Bigg( \prod_{i} {M_i}_\mathrm{BPLA}  P_\mathrm{axis}^{-1} \left(T_1 P_\mathrm{axis} P_\mathrm{axis}^{-1} T_2 P_\mathrm{axis}^{-1} P_\mathrm{axis} \right) \cdot \left(R_1 R_2\right) \\
\cdot \left(S_1 + S_2\right) \cdot P_\mathrm{axis} \Bigg) \cdot M_\mathrm{BPA}^{-1}
\end{multlined}\\
&= \begin{multlined}[t]
\Bigg( \prod_{i} {M_i}_\mathrm{BPLA}  \left(P_\mathrm{axis}^{-1} T_1 P_\mathrm{axis} \right)\left(P_\mathrm{axis}^{-1} T_2 P_\mathrm{axis} \right)  P_\mathrm{axis}^{-1} \left(R_1 R_2\right) \\
\cdot \left(S_1 + S_2\right) \cdot P_\mathrm{axis} \Bigg) \cdot M_\mathrm{BPA}^{-1}
\end{multlined}
\end{align}
We now need to deal with the permutation matrix to the right of the scales. We can note that, whilst the product of a scale and a rotation cannot generally be decomposed as a product of a rotation and a scale ($SR \neq RS' $), this \textit{is} true for the special case where $R$ is a permutation matrix. We can therefore construct scale matrices as $S' = P^{-1}SP$. Applying this, we now find that
\begin{align}
A &= \begin{multlined}[t]
\Bigg( \prod_{i} {M_i}_\mathrm{BPLA}  \left(P_\mathrm{axis}^{-1} T_1 P_\mathrm{axis} \right)\left(P_\mathrm{axis}^{-1} T_2 P_\mathrm{axis} \right)  P_\mathrm{axis}^{-1} \left(R_1 R_2\right) \\
\cdot P_\mathrm{axis}^{-1} P_\mathrm{axis} \left(S_1 + S_2\right) \cdot P_\mathrm{axis} \Bigg) \cdot M_\mathrm{BPA}^{-1}
\end{multlined}\\
&= \begin{multlined}[t]
\Bigg( \prod_{i} {M_i}_\mathrm{BPLA}  \left(P_\mathrm{axis}^{-1} T_1 P_\mathrm{axis} \right)\left(P_\mathrm{axis}^{-1} T_2 P_\mathrm{axis} \right)  \left( P_\mathrm{axis}^{-1} R_1 R_2  P_\mathrm{axis}\right) \\
\cdot \left( \left( P_\mathrm{axis}^{-1} S_1 P_\mathrm{axis}\right) + \left( P_\mathrm{axis}^{-1} S_2 P_\mathrm{axis} \right)\right)\Bigg) \cdot M_\mathrm{BPA}^{-1}
\end{multlined}
\end{align}
We can in principle absorb the permutation matrices into $R_1$ and $R_2$ to create a valid Blender animation equation. However, doing this will mean that the equation is only valid for two rotations. If we add or remove axis-permuted translations or scales from the equation, the equation remains valid because the permutation matrices will always hit an inverse on a neighbouring transform. However, if we want to add (or remove) a rotation, we have to redefine the rotation matrices. For example, if instead of $P^{-1}_\mathrm{axis} R_1 R_2 P_\mathrm{axis}$ we have $P^{-1}_\mathrm{axis} R_1 R_2 R_3 P_\mathrm{axis}$, we have to absorb the right-hand $P_\mathrm{axis}$ into $R_3$ instead of $R_2$. This is clearly not a maintable thing to do in Blender, since Blender allows us to swap the order of animations however we like and import arbitrary numbers of animations.

Luckily, we can introduce composibility by remembering that we already noticed that translations and scales can be arbitrarily combined due to the fact that they are sandwiched between a permutation matrix and an inverse. We can introduce another factor of $P^{-1}_\mathrm{axis}P_\mathrm{axis}$ between the rotation matrices to obtain an animation equation with fully composable transformation components:
\begin{align}
A &= \begin{multlined}[t]
\Bigg( \prod_{i} {M_i}_\mathrm{BPLA}  \left(P_\mathrm{axis}^{-1} T_1 P_\mathrm{axis} \right)\left(P_\mathrm{axis}^{-1} T_2 P_\mathrm{axis} \right)  \left(  P_\mathrm{axis}^{-1} R_1 P_\mathrm{axis}\right) \\
\cdot  \left( P_\mathrm{axis}^{-1} R_2  P_\mathrm{axis} \right) \left(\left(P_\mathrm{axis}^{-1} S_1 P_\mathrm{axis} \right) + \left( P_\mathrm{axis}^{-1} S_2 P_\mathrm{axis}\right)\right) \Bigg) \cdot M_\mathrm{BPA}^{-1}
\end{multlined}
\end{align}
We therefore find the following transformation rules for the transform components under a permutation of axes for the bind pose matrices:
\begin{align}
T_1 &\to P_\mathrm{axis}^{-1} T_1 P_\mathrm{axis}\\
T_2 &\to P_\mathrm{axis}^{-1} T_2 P_\mathrm{axis}\\
R_1 &\to P_\mathrm{axis}^{-1} R_1 P_\mathrm{axis}\\
R_2 &\to P_\mathrm{axis}^{-1} R_2 P_\mathrm{axis}\\
S_1 &\to P_\mathrm{axis}^{-1} S_1 P_\mathrm{axis}\\
S_2 &\to P_\mathrm{axis}^{-1} S_2 P_\mathrm{axis}
\end{align}

\paragraph{Parent-relative transforms to axis-permuted rest-relative transforms}\mbox{}\\
Now that we have found the transformation rules for both constructing rest-relative transforms out of parent-relative transforms, and for moving rest-relative transforms to axis-permuted rest relative transforms, we can now combine the two.

We previously found that we can move from parent-relative to rest-relative transforms with the rules
\begin{align}
T_1 &= R_\mathrm{BPL}^{-1} T_\mathrm{offset} R_\mathrm{BPL}\\
T_2 &= R_\mathrm{BPL}^{-1} T_A R_\mathrm{BPL}\\
R_1 &= R_\mathrm{BPL}^{-1} R_\mathrm{base}\\
R_2 &= R_A\\
S_1 &= S_\mathrm{base}\\
S_2 &= S_a
\end{align}
We then found that we need to insert a factor of $P_\mathrm{axis}^{-1}$ and $P_\mathrm{axis}$ on the left and right of each term respectively. However, we need our equations to all be in terms of $M_\mathrm{BPLA}$, and not $M_\mathrm{BPL}$. Due to this, \textbf{for non-root bones only}, we'll have to insert additional factors of $P_\mathrm{axis}^{-1} P_\mathrm{axis}$ in order to factorise out $M_\mathrm{BPLA}$.

Therefore, the transformation rules for root bones are
\begin{align}
T_1 &= P_\mathrm{axis}^{-1} R_\mathrm{BPL}^{-1} T_\mathrm{offset} R_\mathrm{BPL} P_\mathrm{axis} \\
&= R_\mathrm{BPLA}^{-1} T_\mathrm{offset} R_\mathrm{BPLA}\\
T_2 &= P_\mathrm{axis}^{-1} R_\mathrm{BPL}^{-1} T_A R_\mathrm{BPL} P_\mathrm{axis} \\
&= R_\mathrm{BPLA}^{-1} T_A R_\mathrm{BPLA}  \\
R_1 &= P_\mathrm{axis}^{-1} R_\mathrm{BPL}^{-1} R_\mathrm{base} P_\mathrm{axis} \\
&= R_\mathrm{BPLA}^{-1} R_\mathrm{base} P_\mathrm{axis}\\
R_2 &= P_\mathrm{axis}^{-1} R_A P_\mathrm{axis}\\
S_1 &= P_\mathrm{axis}^{-1} S_\mathrm{base} P_\mathrm{axis}\\
S_2 &= P_\mathrm{axis}^{-1} S_a P_\mathrm{axis}
\end{align}
and for non-root bones,
\begin{align}
T_1 &= P_\mathrm{axis}^{-1} R_\mathrm{BPL}^{-1} P_\mathrm{axis} P_\mathrm{axis}^{-1} T_\mathrm{offset} P_\mathrm{axis} P_\mathrm{axis}^{-1}  R_\mathrm{BPL} P_\mathrm{axis} \\
&= R_\mathrm{BPLA}^{-1} P_\mathrm{axis}^{-1} T_\mathrm{offset} P_\mathrm{axis} R_\mathrm{BPLA}\\
T_2 &= P_\mathrm{axis}^{-1} R_\mathrm{BPL}^{-1} P_\mathrm{axis} P_\mathrm{axis}^{-1}  T_A P_\mathrm{axis} P_\mathrm{axis}^{-1} R_\mathrm{BPL} P_\mathrm{axis} \\
&= R_\mathrm{BPLA}^{-1} P_\mathrm{axis}^{-1} T_A P_\mathrm{axis} R_\mathrm{BPLA}  \\
R_1 &= P_\mathrm{axis}^{-1} R_\mathrm{BPL}^{-1}P_\mathrm{axis} P_\mathrm{axis}^{-1}  R_\mathrm{base} P_\mathrm{axis} \\
&= R_\mathrm{BPLA}^{-1} P_\mathrm{axis}^{-1}  R_\mathrm{base} P_\mathrm{axis}\\
R_2 &= P_\mathrm{axis}^{-1} R_A P_\mathrm{axis}\\
S_1 &= P_\mathrm{axis}^{-1} S_\mathrm{base} P_\mathrm{axis}\\
S_2 &= P_\mathrm{axis}^{-1} S_a P_\mathrm{axis}
\end{align}

In summary, root bone transformations transform to:
\begin{tcolorbox}
\begin{align}
T_1 &= R_\mathrm{BPLA}^{-1} T_\mathrm{offset} R_\mathrm{BPLA}\\
T_2 &= R_\mathrm{BPLA}^{-1} T_A R_\mathrm{BPLA}  \\
R_1 &= R_\mathrm{BPLA}^{-1} R_\mathrm{base} P_\mathrm{axis}\\
R_2 &= P_\mathrm{axis}^{-1} R_A P_\mathrm{axis}\\
S_1 &= P_\mathrm{axis}^{-1} S_\mathrm{base} P_\mathrm{axis}\\
S_2 &= P_\mathrm{axis}^{-1} S_a P_\mathrm{axis}
\end{align}
\end{tcolorbox}
and, non-root bone transformations transform to:
\begin{tcolorbox}
\begin{align}
T_1 &= R_\mathrm{BPLA}^{-1} P_\mathrm{axis}^{-1} T_\mathrm{offset} P_\mathrm{axis} R_\mathrm{BPLA}\\
T_2 &= R_\mathrm{BPLA}^{-1} P_\mathrm{axis}^{-1} T_A P_\mathrm{axis} R_\mathrm{BPLA}  \\
R_1 &= R_\mathrm{BPLA}^{-1} P_\mathrm{axis}^{-1}  R_\mathrm{base} P_\mathrm{axis}\\
R_2 &= P_\mathrm{axis}^{-1} R_A P_\mathrm{axis}\\
S_1 &= P_\mathrm{axis}^{-1} S_\mathrm{base} P_\mathrm{axis}\\
S_2 &= P_\mathrm{axis}^{-1} S_a P_\mathrm{axis}
\end{align}
\end{tcolorbox}


\subsubsection{Mesh Animations}
A mesh will interact with the scene graph differently depending on whether it is weighted or unweighted. The unweighted case is the simplest: the entire mesh is transformed by the transform of the node it is attached to. The GFS animation equation for vertices in such a mesh is then
\begin{equation}
v'  = A_\mathrm{GFS} v,
\end{equation}
where $v$ is the position of the vertex before animation, and $v'$ is the position of the vertex after animation. 

To shift this to the Blender equation, we need to just insert $M_\mathrm{BP}^{-1}M_\mathrm{BP}$ between $A_\mathrm{GFS}$ and $v$, factor out $A_\mathrm{GFS}M_\mathrm{BP}^{-1} = A_\mathrm{Blender}$, and then we apply whatever transforms from the previous sections we need to to $A_\mathrm{Blender}$. This ultimately gives us
\begin{equation}
v'  = A_\mathrm{Blender} M_\mathrm{BP} v,
\end{equation}
which tells us we need to transform the mesh to $M_\mathrm{BP}$ in Blender and then hook into the bone animation system. We can do this either by parenting the mesh to the bone, or by rigging every vertex in the mesh to a single bone and transforming the mesh to the bone transform.

For the weighted case, we have a largely ``standard" mesh deformation pipeline. The standard mesh deformation equation is
\begin{equation}
v' = \left( \sum_i w_i A_i M_{\mathrm{BP}, i}^{-1} \right) M_\mathrm{mesh} v,
\end{equation}
where $i$ is a bone index, $w_i$ is the coupling weight between the bone and vertex (normalised such that $\sum_i w_i = 1$), $A_i$ is the animation matrix of the bone $i$, $M_{\mathrm{BP}, i}^{-1}$ is the bind pose matrix for the bone $i$, and $M_\mathrm{mesh}$ is the transform of the mesh. The GFS weighted mesh animation equation is in fact identical, with the exception that the matrix $M_\mathrm{mesh}$ is baked into the matrices $M_\mathrm{BP, i}$ such that
\begin{equation}
v' = \left( \sum_i w_i A_i M_{\mathrm{BPMR}, i}^{-1} \right) v,
\end{equation}
where $M_{\mathrm{BPMR}}$ is a \textbf{M}esh-\textbf{R}elative \textbf{B}ind \textbf{P}ose matrix, defined as $M_{\mathrm{BPMR}}^{-1} = M_\mathrm{BP}^{-1} M_\mathrm{mesh}$. Note that even if the node a mesh is attached to in the GFS files is animated, this node animation does not factor into the vertex animation - only the original pose of the node (as baked into the bind pose matrices) and the weighted bones influence the final position of the vertex.

To import this into Blender, we need to ``unbake" the mesh transformation matrices from the bind pose matrices. Two ways we can do this are:
\begin{itemize}
\item Construct the mesh transformation matrix from the node transforms.
\item Evaluate the animation equation for a specific pose, and define that pose as a new bind pose.
\end{itemize}

The first of these is very simple to do:
\begin{equation}
v' = \left( \sum_i w_i A_i M_{\mathrm{BPMR}, i}^{-1} M_{\mathrm{mesh}}^{-1} \right)  M_{\mathrm{mesh}} v,
\end{equation}
but if the file contains node transforms for the mesh that are inconsistent with those used to build the bind pose matrices (\textit{i.e.} this file is incorrect) or the mesh transform cannot be decomposed to just a transformation, rotation, and scale, then this will not work.

The second of these methods gives us an animation equation that looks like
\begin{equation}
v' = \left( \sum_i w_i A_i M_{\mathrm{BP}, i}^{-1} \right) v_\mathrm{baked},
\end{equation}
where $v_\mathrm{baked}$ is pre-computed as
\begin{equation}
v_\mathrm{baked} = \left( \sum_i w_i A_{\mathrm{BP}_i} M_{\mathrm{BPMR}, i}^{-1} \right) v
\end{equation}
and directly used as mesh vertices. Here, $A_{\mathrm{BP}_i}$ is the animation matrix that takes the bones to whichever bind pose we define. In order to preserve bone scales in Blender, it makes sense to choose this bind pose to be just the translation and rotation components of the node transforms, since this will allow scales to be separated into the rest pose and is likely to not deform the overall shape of the mesh since the bind and rest poses are typically very similar---in general this cannot be guaranteed, but the mesh shape will be recovered in the rest pose.

This second method has the advantage that it will always reproduce what is observed in-engine, but comes with the cost of making the imported meshes less useful: if the rest and bind poses are too different, the mesh will be imported in a shape that is difficult to edit; and baking the mesh transform into the vertices means that they will scale and rotate with respect to the origin rather than the original centre point of the mesh.


\end{document}
